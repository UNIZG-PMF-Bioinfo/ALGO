---
title: "Week 1 - Lecture 2"

format:
  html:
    self-contained: true
    toc: true
    toc-depth: 5
    code-fold: false
    fig-align: center
    df-print: paged
    code-summary: "Show code"
    code-line-numbers: false
    code-tools: true
---

## Functions

### General structure:

myfun **\<- function(**input, parameters**) {**\
do a thing\
do another thing\
...\
output\
**}**

**Write a function**

Make a simple function which will multiplies two numbers.

```{r}
mySimpleFun <- function(a=1,b) {
    product <- a*b
    return(product)
}
```

The function will return whatever is called on the last line, or you can explicitly state it with **return()**.

**Execution i.e. calling a function**

```{r}
mySimpleFun(b=3)
mySimpleFun(a=2, b=3)
mySimpleFun(2, 3)
```

## Global and local variables

```{r, eval=FALSE}
mySimpleFun <- function(a=1,b) {
    product <- a*b
    return(product)
}
```

What happens with the function if we change variable vol outside it? Nothing! The function has its own **local environment**.

```{r}
product <- 5
mySimpleFun(2, 3)
product
```

## Function as binary operator

All functions are beautiful, but not all come in the same shape :)

An **operator** is a function that takes one or two arguments and can be written without parentheses

**function(**arg1, arg2**)**\
vs.\
arg1 **operator** arg2

Operator **%in%** is used to identify if an element belongs to a vector or dataframe.

```{r}
c(1,4,2,1) %in% c(2,3)
```

## Multiple inputs / vectorisation

```{r}
mySimpleFun(1:3, 3:5)
```

## Flow control: if statement

**if(**condition is fulfilled**) {**\
do the thing\
**} else {**\
do the other thing\
**}**

```{r}
mySimpleFun <- function(a=1,b) {
    if (a < 0) {
        a <- (-1)*a
    } else {
        a <- a
    }
    
    product <- a*b
    return(product)
}
```

## Warnings, errors and messages

You are getting the hang of this, and with an additional pair of hands the work is coming along quickly. But after one calculation, you notice the numbers are fishy. Upon closer inspection, you discover that you input thickness with a decimal dot in the wrong place. To prevent this from happening again and going unnoticed, you add a **warning()**:

```{r}
mySimpleFun <- function(a=1,b) {
    if (a < 0) {
        warning("First number is negative! Changing it to positive.")
        a <- (-1)*a
    } else {
        a <- a
    }
    
    product <- a*b
    return(product)
}
```

If you want the function to stop executing, use **break()**.\
**message()** has similar syntax but different "level of alert".

## Multiple outputs

```{r}
mySimpleFun <- function(a=1,b) {
    if (a < 0) {
        warning("First number is negative! Changing it to positive.")
        a <- (-1)*a
    } else {
        a <- a
    }
    # calculate product
    product <- a*b
    # make a figure
    figure <-  plot(c(a,b))
    # save a list
    res_list <- list("product"=product, "figure"=figure)
    # return
    return(res_list)
}
## run the fuction
mySimpleFun(b=-2)
```

**`ifelse(test, yes, no)`** - vectorised

```{r}
mySimpleFun <- function(a=1,b) {
  # make all negatives positive
  a <- ifelse(a < 0, -a, a)

  # calculate product
  product <- a * b

  # (plots will only show the last one in a loop, so you usually donâ€™t do this inside)
  plot(a, b)   # e.g. scatter plot

  list(product = product)
}

mySimpleFun(a= c(2,3,2,-1), b=c(3,4,5,2))
```

Try to change 'list' with 'c' and see what happens. You have to put multiple outputs together as a list, otherwise it doesn't work properly!

## Looping in R

**for(**each value in sequence**) {**\
do the thing\
**}**

```{r}
for(i in 1:5) {
    print("bla")
}
```

**while(**condition is true**) {**\
do the thing\
**}**

**repeat {**\
the thing\
**if(**condition is true**) { break }**\
**}**

It's **NEVER** a time for a loop in R. Instead, there's the **apply()** family of functions:

## Apply family of functions

**lapply()**:

```{r}
lapply(iris[, 1:4], sum)          # preforms a function over each list element
class(lapply(iris[, 1:4], sum))   # returns a list
```

Notice the three dots (ellipsis) in function description: `lapply(X, FUN, ...)`

Access list entries explicitly by using **function(x)**:

```{r}
lapply(iris[, 1:4], function(x) sqrt(x[20:30]))
```

## Apply family of functions

**`sapply()`** : lapply, but tries to return simpler data format

```{r}
sapply(iris[, 1:4], sum)
class(sapply(iris[, 1:4], sum))
```

## Apply family of functions

**`apply()`** : apply function over margins of array (1 for rows, 2 for columns)

```{r}
apply(iris[, 1:4], 1, sum)
```

## Apply family of functions

**`replicate()`** : repeated evaluation of expression; returns an array

```{r}
replicate(3, sample(1:10, 5))
```

## Take home messages on writing your own functions

Take care of the future user of your function - it'll probably be you.

-   tidy and clear commands - avoid salami code
-   tidy and logical higher structures - avoid spaghetti code
-   sensible function and variable names
-   (b, bb, bbs, dajproradivise, omg, matfixmerggr)
-   COMMENT YOUR CODE

```{r}
# example of salami code:
sum(as.numeric(names(table(sample(50:300, 1000, replace=T) %/% 25))))   
```

vs.

```{r}
mysample <- sample(50:300, 1000, replace=T)
roundit <- mysample %/% 25
tb <- table(roundit)
tb
categories <- as.numeric(names(tb))
categories
cat_sum <- sum(categories)
cat_sum
```

Most importantly, if there is already a function for what you are trying to do, don't write your own without a good reason. (Homework instructions are a good reason.)

# The end
