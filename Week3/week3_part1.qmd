---
title: "Data visualization with ggplot2"
author: 
  - name: "Rosa Karlić"
    affiliation: "Bioinformatics group"
format:
  html:
    self-contained: true
    toc: true
    toc-depth: 5
    code-fold: false
    fig-align: center
    df-print: paged
    code-summary: "Show code"
    code-line-numbers: false
    code-tools: true
execute:
  echo: true
  warning: false
  message: false
editor: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
## First specify the packages of interest
packages <- c("gt", "data.table",  "tidyverse")

## Install if missing, then load
lapply(packages, function(x) {
  if (!requireNamespace(x, quietly = TRUE)) {
    install.packages(x)
  }
  library(x, character.only = TRUE)
})

```

## **Tidy Data**

Tidy data makes the analysis easier to do, faster to check, easier to
plot and to reuse for other analysis. If you have a messy dataset and
you think that it is exactly what you need, you will most likely use it
only once - for one analysis and a single graph.

```         

1. Each variable forms a column.

2. Each observation forms a row.

3. Each type of observational unit forms a table.
```

```{r fig1, echo = FALSE, out.width = "100%", fig.cap = "Fig1. Rules that make data tidy"}
knitr::include_graphics("images/tidy_example1.png")
```

### Tidy data vs. messy data

Examples of messy and tidy datasets (based on a dataset of TB cases in
different countries).

```{r fig2, echo = FALSE, out.width = "100%", fig.cap = "Fig2. Messy data"}
table1_wide = dcast(as.data.table(table1), country ~ year, value.var = c("cases", "population"))
gt(table1_wide)
```

```{r fig3, echo = FALSE, out.width = "80%", fig.cap = "Fig3. Tidy data"}

gt(table1)

```

Advantages of using tidy data:

1.  Consistent data structure makes it easier to learn the tools that
    work with it because they have an underlying uniformity.

2.  Placing variables in columns makes use of R's vectorization
    (functions and operations automatically apply element-wise to entire
    vectors).

    For more information see [Chapter 5: Data
    tidying](https://r4ds.hadley.nz/data-tidy.html) from

    Grolemund, G., Çetinkaya-Rundel, M., & Wickham, H. (2023). R for
    Data Science (2nd ed.). O'Reilly Media.

### Tidyverse

-   Coherent system of packages for data manipulation, exploration and
    visualization that share a common design philosophy
-   Mostly developed by Hadley Wickham
-   https://www.tidyverse.org/

```{r fig4, echo = FALSE, out.width = "100%", fig.cap = "Fig3. Tidyverse"}
knitr::include_graphics("images/tidyverse1.png")

```

More information: [What is the
tidyverse](https://rviews.rstudio.com/2017/06/08/what-is-the-tidyverse/)

### Data tidying - example

This dataset represents simulated qPCR (quantitative PCR) results used
to measure gene expression differences between a control group and a
treatment group over a 24-hour time point. Each sample has Ct (cycle
threshold) values for both a target gene (the gene of interest) and a
reference gene (a housekeeping gene used for normalization), measured
across two technical replicates. The raw data are intentionally messy
and wide-formatted, resembling typical qPCR output files that contain
mixed data types, missing values, inconsistent naming, and combined
experimental variables (e.g., "Treatment_24h").

Our goal is to clean and restructure this data into a tidy format where
each observation corresponds to a single sample-replicate pair, with
separate columns for condition, time, and gene measurements.

First we will simulate some data:

```{r}
set.seed(42)

# ---- 1. Simulate MESSY qPCR data (wide format) ----

messy_qpcr <- data.table(
  Sample = c("ctrl_1", "ctrl_2", "ctrl3", "treat1", "treat_2", "treat_3"),
  Target_CT_Rep1 = c(22.1, 23.0, "22_low", 18.5, 19.3, 18.9),
  Target_CT_Rep2 = c(22.3, "missing", 21.9, 18.4, 19.5, 19.0),
  Ref_CT_Rep1 = c(20.0, "20.2", "19.8", 18.0, 17.7, "err"),
  Ref_CT_Rep2 = c("19.9", 20.1, 19.9, 18.1, "error", 17.8),
  Condition_Time = c("Control_24h", "Control_24h", "Control_24h", "Treatment_24", "Treatment_24h", "Treatment_24h")
)

gt(messy_qpcr, caption="Messy wide-format data")

```

**Q1: What is messy about this data?**

We now have to tidy the data so that each row corresponds to one
observation. We will use data.table for this.

```{r}
# ---- 2. Clean the data ----
# Convert non-numeric Ct values
# get the vector of column names with CT
not_numeric_CT <- names(messy_qpcr[,.SD,.SDcols=patterns("CT")])
# clean the values in those columns
messy_qpcr[, (not_numeric_CT) := lapply(.SD, function(x) {
  x <- gsub("_low", "", x)                    # remove "_low"
  x[x %in% c("missing", "error", "err")] <- NA  # replace text errors with NA
  as.numeric(x)                               # convert to numeric
}),
  .SDcols = not_numeric_CT
]

# Fix inconsistent naming in condition
messy_qpcr[, Condition_Time := gsub("Treatment_24$", "Treatment_24h", Condition_Time)]

# ---- 3. Transform to tidy format ----
# Melt replicates to long form
tidy_qpcr <- melt(
  messy_qpcr,
  id.vars = c("Sample", "Condition_Time"),
  measure.vars = patterns(Target = "^Target_CT_", Reference = "^Ref_CT_"),
  variable.name = "Replicate"
)

# Split condition and time
tidy_qpcr[, c("Condition", "Time") := tstrsplit(Condition_Time, "_", fixed = TRUE)]

gt(tidy_qpcr, caption = "Tidy qPCR data")
```

### Writing and saving data

We can write the tidied dataset to a file using various functions
(*write.table()*, *write.csv()*, *write.tsv()*). However, the variable
type information for different columns will be lost if we read the data
back in from the file.

This is why we can directly save the objects that we created using
*save()* or *saveRDS()*.

save()

-   Saves one or more R objects to a binary .RData file.

-   Loads all saved objects with original names using load().

saveRDS()

-   Saves a single R object to a .rds file.

-   Allows loading with a new name using readRDS().

-   More flexible for saving/loading single objects.

```{r}
# Save the tidy_qpcr object to a RDS file
saveRDS(tidy_qpcr, "tidied.qpcr.data.rds")

# Use list.files() function to check whether the file got created
list.files(pattern = "rds")

# Load the object under a different name
tidy_new = readRDS("tidied.qpcr.data.rds")

# Check if the metadata is preserved
str(tidy_qpcr)
str(tidy_new)

```

We can use *save()* to save individual objects or the entire
environment.

```{r}
# Saves all objects
save(list = ls(), file = "my_workspace.RData")
# Saves all objects
save(list = ls(), file = "my_workspace2.RData")

list.files(pattern = "RData")
```

### Data tidying - example continued

Since out data is now tidy, we now want to calculate normalized gene
expression levels for relative quantification of gene expression from
qPCR (quantitative PCR) data. We will use the $\Delta\Delta$Ct method.

```{r fig5, echo = FALSE, out.width = "100%", fig.cap = "Fig5. delta_delta_Ct method"}
knitr::include_graphics("images/deltaCt_method.png")
```

To calculate $\Delta\Delta$Ct we need to perform the folowing steps:

```{r fig6, echo = FALSE, out.width = "100%", fig.cap = "Fig6. delta_delta_Ct calculation"}
knitr::include_graphics("images/deltaCt_diagram.png")
```

We will now perform the necessary steps on our tidied qPCR dataset.

```{r}
# ---- 4. Calculate ΔCt ----
tidy_qpcr[, delta_Ct := Target - Reference]

# ---- 5. Calculate ΔΔCt ----
mean_control_deltaCt <- tidy_qpcr[Condition == "Control", mean(delta_Ct, na.rm = TRUE)]
tidy_qpcr[, delta_delta_Ct := delta_Ct - mean_control_deltaCt]

# ---- 6. Calculate relative expression ----
tidy_qpcr[, rel_expression := 2^(-delta_delta_Ct)]

# ---- 7. Summarize per condition ----
summary_qpcr <- tidy_qpcr[, .( mean_deltaCt = mean(delta_Ct, na.rm =
TRUE), mean_rel_expression = mean(rel_expression, na.rm = TRUE) ), by =
Condition]


gt(tidy_qpcr, caption = "ΔΔCt and relative expression results")
gt(summary_qpcr, caption = "Summary results")
```

You can check out this [tutorial on qPCR
analysis](https://cran.r-project.org/web/packages/pcr/vignettes/qpcr_analysis.html#analysis-methods)
for more details.

## **Types of graphs in R**

### Graphs in R

Variable types:

-   categorical :

    ```         
      nominal  
      ordinal    
    ```

-   quantitative :

    ```         
      numerical discrete  
      numerical continuous  
    ```

Appropriate graphs depend on the number and type of variables that we
are plotting.

```{r fig7, echo = FALSE, out.width = "100%", fig.cap = "Fig7. Graphs by variable type"}
knitr::include_graphics("images/graph_types.png")
```

Let's again simulate some data which we will use for different types of
visualizations.

```{r}
set.seed(123)

# Simulate dataset

n_samples <- 40

df <- data.table(
  SampleID = paste0("S", 1:n_samples),
  Treatment = rep(c("Control", "Treated"), each = n_samples/2),
  CellType = sample(c("TypeA", "TypeB"), n_samples, replace = TRUE),
  Mutation = sample(c("WT", "Mut"), n_samples, replace = TRUE),
  NumMutations = sample(0:5, n_samples, replace = TRUE),
  Gene1_expr = rnorm(n_samples, mean = ifelse(rep(c("Control", "Treated"), each = n_samples/2) == "Control", 10, 12), sd = 2),
  Gene2_expr = rnorm(n_samples, mean = ifelse(rep(c("Control", "Treated"), each = n_samples/2) == "Control", 8, 9), sd = 1.5),
  Protein_expr = rnorm(n_samples, mean = ifelse(rep(c("Control", "Treated"), each = n_samples/2) == "Control", 50, 60), sd = 8)
)

gt(head(df, n= 10), caption = "Dataset for visualizations")
```

*Categorical variables example:*

```{r, echo=FALSE, message=FALSE, warning=FALSE}
# Categorical: bar plot
ggplot(df, aes(x = Treatment, fill = Treatment)) +
  geom_bar() +
  labs(title = "Bar plot: Treatment groups")
```

*Quantitative variables examples:*

Numerical continuous:

```{r echo = FALSE}
# Continuous: histogram
ggplot(df, aes(x = Gene1_expr)) +
  geom_histogram(binwidth = 1, fill="skyblue", color="black") +
  labs(title = "Histogram: Gene1 expression")

# Continuous: density plot
ggplot(df, aes(x = Protein_expr)) +
  geom_density(alpha=0.5, fill = "red") +
  labs(title = "Density plot: Protein expression")

# Continuous: boxplot
ggplot(df, aes(y = Gene2_expr)) +
  geom_boxplot(fill="orange") +
  labs(title = "Boxplot: Gene2 expression")

# Continuous: violin
ggplot(df, aes(y = Protein_expr,  x = factor(1))) + 
  labs(title = "Violin: Protein expression")+
  theme(axis.ticks.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.title.x = element_blank())
```

Numerical discrete:

```{r echo = FALSE}
# Discrete numeric: bar plot
ggplot(df, aes(x = NumMutations)) +
  geom_bar(fill="purple") +
  labs(title = "Bar plot: Number of mutations per sample")
```

### Graphs with two variables: Continuous X, Continuous Y

```{r echo = FALSE}
# Continuous vs Continuous: scatter
ggplot(df, aes(x = Gene1_expr, y = Gene2_expr)) +
  geom_point(color="darkgreen") +
  labs(title = "Scatter: Gene1 vs Gene2 expression")

# Continuous vs Continuous: scatter + regression
ggplot(df, aes(x = Gene1_expr, y = Gene2_expr, color = Treatment)) +
  geom_point() +
  geom_smooth(method="lm") +
  labs(title = "Scatter + Linear fit: Gene1 vs Gene2")

# Continuous vs Continuous: bubble plot
ggplot(df, aes(x = Gene1_expr, y = Gene2_expr, size = Protein_expr, color = Treatment)) +
  geom_point(alpha=0.7) +
  labs(title = "Bubble plot: Gene1 vs Gene2 (Protein size)")

```

### Graphs with two variables: Discrete X, Continuous Y

```{r echo = FALSE}
# Continuous vs Discrete: boxplot
ggplot(df, aes(x = Treatment, y = Gene1_expr, fill = Treatment)) +
  geom_boxplot() +
  geom_jitter(width=0.2, alpha=0.6) +
  labs(title = "Boxplot: Gene1 expression by treatment")

# Continuous vs Discrete: violin
ggplot(df, aes(x = CellType, y = Protein_expr, fill = CellType)) +
  geom_violin() +
  labs(title = "Violin: Protein expression by cell type")

# Continuous vs Discrete: bar (mean ± SD)
df_summary <- df %>%
  group_by(Treatment) %>%
  summarise(mean_expr = mean(Protein_expr),
            sd_expr = sd(Protein_expr))

ggplot(df_summary, aes(x = Treatment, y = mean_expr, fill = Treatment)) +
  geom_col() +
  geom_errorbar(aes(ymin=mean_expr-sd_expr, ymax=mean_expr+sd_expr), width=0.2) +
  labs(title = "Mean protein expression ± SD by treatment")

# Continuous vs Discrete: histogram
ggplot(df, aes(x = Gene1_expr, fill = Treatment)) +
  geom_histogram(binwidth=1, alpha=0.6, position="identity") +
  labs(title = "Histogram: Gene1 expression by treatment")

# Continuous vs Discrete: lollipop plot
ggplot(df, aes(x = SampleID, y = Gene1_expr)) +
  geom_segment(aes(x = SampleID, xend = SampleID, y = 0, yend = Gene1_expr), color = "grey") +
  geom_point(aes(color = Treatment), size = 4) +
  coord_flip() +  # for horizontal orientation
  theme_minimal() +
  labs(title = "Lollipop plot: Gene1 expression by treatment")
```

### Graphs with two variables: Discrete X, Discrete Y

```{r echo = FALSE}
# Discrete vs Discrete: stacked bar
ggplot(df, aes(x = Treatment, fill = CellType)) +
  geom_bar(position="stack") +
  labs(title = "Stacked Barplot: CellType per treatment")

# Discrete vs Discrete: grouped bar
ggplot(df, aes(x = Treatment, fill = Mutation)) +
  geom_bar(position="dodge") +
  labs(title = "Grouped Barplot: Mutation per treatment")

# Discrete vs Discrete: heatmap
df_counts <- df %>% count(CellType, Mutation)
ggplot(df_counts, aes(x = CellType, y = Mutation, fill = n)) +
  geom_tile() +
  labs(title = "Heatmap: CellType vs mutation counts")
```

**Q2: Let's simulate another tidy qPCR dataset. What would be the
appropriate graphs for the following research questions:**

```{r}
set.seed(123)

genes <- c("TP53", "MYC", "GAPDH", "BRCA1")
n_samples <- 8

# Create samples data.table
samples <- data.table(
  SampleID = paste0("S", 1:n_samples),
  Condition = rep(c("Control", "Treated"), each = n_samples/2)
)

# Create qpcr_raw by expanding genes and SampleID, joining sample info, and simulating Ct values
qpcr_raw <- CJ(Gene = genes, SampleID = samples$SampleID)[
  samples, on = "SampleID"
][
  , Ct := fifelse(Gene == "TP53" & Condition == "Control", rnorm(.N, 22, 1),
           fifelse(Gene == "TP53" & Condition == "Treated", rnorm(.N, 20, 1),
           fifelse(Gene == "MYC" & Condition == "Control", rnorm(.N, 18, 1),
           fifelse(Gene == "MYC" & Condition == "Treated", rnorm(.N, 17, 1),
           fifelse(Gene == "BRCA1" & Condition == "Control", rnorm(.N, 24, 1),
           fifelse(Gene == "BRCA1" & Condition == "Treated", rnorm(.N, 22, 1),
           rnorm(.N, 15, 0.5)))))))]

# Compute deltaCt normalized to GAPDH Ct per SampleID
qpcr_dCt <- merge(
  qpcr_raw,
  qpcr_raw[Gene == "GAPDH", .(SampleID, Ct_ref = Ct)],
  by = "SampleID"
)[
  , deltaCt := Ct - Ct_ref
]

# Compute deltaDeltaCt and fold change by gene
qpcr_ddCt <- qpcr_dCt[
  , .(mean_dCt_control = mean(deltaCt[Condition == "Control"])), by = Gene
][
  qpcr_dCt, on = "Gene"
][
  , deltaDeltaCt := deltaCt - mean_dCt_control
][
  , fold_change := 2^(-deltaDeltaCt)
][
  Gene != "GAPDH"  # filter out reference gene
]



gt(qpcr_ddCt, caption = "Tidied qPCR data, example 2")
```

1.  Comparison of TP53 and MYC expression
2.  Comparison of ΔCt values across control and treated samples
3.  Average protein levels per treatment group
4.  Value of deltaDeltaCt by sample and gene

### ggplot2 vs. base R plots

plot() - generic function in base R (type of plot depends on the
type/class of the first argument)

```{r, echo=FALSE}
plot(df$Gene1_expr, df$Gene2_expr, col=factor(df$Treatment), 
     main = "Base R")
```

```{r, echo=FALSE}
ggplot(df, aes(Gene1_expr, Gene2_expr, color=Treatment)) + 
  geom_point()+
  theme_light()+
  ggtitle("ggplot2") +
  theme(plot.title = element_text(hjust=0.5))


```

Check out [ggplot cheat
sheet](https://rstudio.github.io/cheatsheets/data-visualization.pdf) to
see which type of plot fits your kind of data.

## **Basics of ggplot2**

### Basic ggplot logic: ggplot(data, aes(x,y))

The ggplot() object acts as a storage facility for the data. It is here
where we define the data frame that houses the x and y coordinate values
themselves and instructions on how to split the data. There are three
ways to initialise a ggplot() object:

`p <- ggplot()`

`p <- ggplot(data_frame)`

`p <- ggplot(data_frame, aes(x, y))`

Displaying the object p generated in the code chunk above would result
in Error: No layers in plot. This is because you always need at least
one layer for a ggplot.

### Mapping aesthetics to data

The aes() aesthetic mapping function lives inside a ggplot object and is
where we specify the set of plot attributes (x and y axis, color) that
remain constant throughout the subsequent layers (unless overwritten,
more on this later).

We can consider the relationship between the aes() and geoms components
as follows:

The aes() function is *how* data is stored, how data is split, and geoms
is *what* the data looks like. These are geometrical objects stored in
subsequent layers.

### Layers

We use the + operator to construct. By appending layers we can connect
the "how" (aesthetics) to the "what" (geometric objects). Adding
geometric, scale, facet and statistic layers to a ggplot() object is how
to control virtually every visual aspect of the plot from the data
contained in the object.

### Adding a geometric object layer

A geometric object is used to define the style of the plot. Common
geometric objects include:

geom_point() which is used to draw a dot plot\
geom_line() used to draw a line plot\
geom_bar() used to draw a bar chart.

Available graphs can be seen at [R graph
gallery](https://www.r-graph-gallery.com/ggplot2-package.html)

### Facets

Appending a facet layer to a ggplot generates the same plot for
different subsets of data.

### Statistics

Exploratory data analysis can be done using the base packages in R, the
results of which can be added to a ggplot() in the guise of a geom
layer.

### Data for examples

In this lecture we will be using microarray expression data for 2
microarray probes measured in leukemia patients with different cancer
stages. The data is available at
http://hex.bioinfo.hr/\~rosa/R_workshop/1242_at.leukemia.txt and
http://hex.bioinfo.hr/\~rosa/R_workshop/1866_g\_at.leukemia.txt

```{r }
# read in the data for the 1242_at probe expression levels

data <- read.delim("http://hex.bioinfo.hr/~rosa/R_workshop/1242_at.leukemia.txt");data
```

### Example: basic layout

-   x axis is categorical, y axis is numerical

Set the basic layout:

-   We want to analyze the 1242_at probe and visualize the differences
    of expression across stages. Produce a layout in which the x axis
    represents the stage and the y axis represents expression of the
    1242_at probe.

```{r read_data1}
# read in the data for the 1242_at probe expression levels

data <- read.delim("http://hex.bioinfo.hr/~rosa/R_workshop/1242_at.leukemia.txt")
```

**Hint:** You need to tell ggplot what your data is and define the
aesthetics.

```{r }
# create a layout in which x axis to represent stage and y to represent expression

p <- ggplot(data, aes(x = stage, y = expression))
p
```

### Example: add a layer - graph type

Choose the graph type that you want to show. Lets say we want a
scatterplot of 1242_at expression values for each stage. Add
geom_point() to your layout.

**Hint:** We need to define data and aesthetics and add layers to the
existing plot using "+".

```{r points}
# add points to your plot

p <- ggplot(data, aes(x = stage, y = expression)) + geom_point()
p
```

<div>

</div>

### Example: modifying the graph with aesthetics

Aesthetics can be defined inside the ggplot() call or inside individual
layers. Color the points by stage. Do this inside geom_point.

```{r modify, exercise=TRUE, evaluate=FALSE, exercise.setup = "read_data1"}
# color the points by stage


```

```{r modify-solution}
p <- ggplot(data, aes(x = stage, y = expression)) + geom_point(aes(color = stage))
p
```

### Example: add another layer (boxplot)

We wanted a scatterplot but changed out mind and now we also want
boxplot on top of this scatterplot. Add + geom_boxplot() to the previous
line to see what you get.

**Hint:** Layers are added using "+".

```{r}
# add a boxplot layer

p <- ggplot(data, aes(x = stage, y = expression)) + geom_point(aes(color = stage)) + geom_boxplot()
p
```

There are also color palettes such as viridis palette designed to be
perceived by viewers with common forms of color blindness.

```{r}
p <- ggplot(iris, aes(x=Species, y=Sepal.Length, fill= Species)) +
  geom_boxplot() + 
  scale_fill_viridis_d()+
  theme_light()
p
```

### Example: Setting aesthetics

The *aes()* function in ggplot2 maps data variables to visual properties
(aesthetics) and can be specified: - inside *ggplot()* to apply
globally - inside individual layers to apply locally - set outside
*aes()* to apply a constant value rather than a mapped variable

```{r}

# 1. Aesthetics mapped inside aes(): color mapped to Species (varies by data)
p1 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +
  geom_point() +
  ggtitle("Color mapped inside aes()")
p1

# 2. Aesthetics set outside aes(): color fixed to blue for all points 
p2 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_point(color = "blue") +
  ggtitle("Color set outside aes()")
p2

# 3. Aesthetics mapped inside aes() globally, and overridden or added in layer's aes():
p3 <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width)) +
  geom_point(aes(color = Species)) +   # color mapped per Species, local layer aes()
  geom_smooth(method = "lm", color = "black") +  # smooth line fixed black color, outside aes()
  ggtitle("Color aes() in point layer, fixed color outside aes() in smooth")
p3
```

### Example: Identify parts of the plot are produced by which part of command

```{r}
set.seed(123)
molecular_data <- data.frame(
  TP53 = rnorm(50, mean = 10, sd = 3),
  BRCA1 = rnorm(50, mean = 8, sd = 2),
  DiseaseStatus = rep(c("Healthy", "Tumor"), each = 25)
)

p2 <- ggplot(molecular_data, aes(x = TP53, y = BRCA1, color = DiseaseStatus)) +
  geom_point() +
  geom_smooth(method = "lm", color = "red") +
  labs(title = "Gene expression: TP53 vs BRCA1 by disease status",
       x = "TP53 expression (log2 counts)",
       y = "BRCA1 expression (log2 counts)")

p2

```

For each plot element below, identify which part of the ggplot2 command
produced it:

1.  The scatter plot points colored by disease status

2.  The red smoothing line (linear regression)

3.  The main plot title

4.  The x-axis label

5.  The y-axis label

6.  The specification of which genes are on the x and y axes

7.  The plot panel background and gridlines

## Facets

### Example 3: Let's build another graph

We want to see if there is any connection between expression of probe
1242_at and probe 1866_g\_at in the leukemia dataset. We will create a
graph with numerical x (1242_at expression) and y (1866_g\_at
expression) axes.

First let's read in and combine the datasets.

```{r read_and_combine, exercise = TRUE}
# Read data with fread for efficiency
data1 <- fread("http://hex.bioinfo.hr/~rosa/R_workshop/1242_at.leukemia.txt")
data2 <- fread("http://hex.bioinfo.hr/~rosa/R_workshop/1866_g_at.leukemia.txt")

# Rename the 'expression' columns by reference
setnames(data1, "expression", "expression_1242_at")
setnames(data2, "expression", "expression_1866_g_at")

# Perform an inner join on 'row.names' and 'stage' columns
data <- merge(data1, data2, by = c("V1", "stage"), all = FALSE)

# View the result
head(data)
```

Now we want to make a scatterplot and see whether there is any
connection between expression_1242_at (x axis) and expression_1866_g\_at
(y axis) in leukemia dataset.

**Hint:** You need to make a basic layer, define aesthetics and add a
layer with the points.

```{r}
# make a scatterplot with expression_1242_at on the x axis and expression_1866_g_at on the y axis

p <- ggplot(data, aes(x = expression_1242_at, y = expression_1866_g_at)) + geom_point() 
p
```

<div>

</div>

This looks ok but now we would like for each stage to appear in its own
graph. For this use facet_wrap(). Parameter to facet_wrap is the
variable by which you would want to separate the graphs (\~variable2).
If you put \~variable2, then the graph will be separated into as many
columns as there are levels in variable2. Lets separate our scatterplot
to columns by "stage" variable.

**Hint:** You need to add a facet to the previous plot.

```{r facet}
# make a scatterplot with expression_1242_at on the x axis and expression_1866_g_at on the y axis

p <- ggplot(data, aes(x = expression_1242_at, y = expression_1866_g_at)) + geom_point() +facet_wrap(~stage)
p
```

<div>

</div>

## Statistics

Let's do some exploratory analysis and add linear regression lines to
the plot, to check whether the relationship between the expression
values of the two probes is similar in all stages. We can check this by
adding geom_smooth() to the plot.

```{r}
# add linear regression lines to the plot with the facets


p <- ggplot(data, aes(x = expression_1242_at, y = expression_1866_g_at)) + geom_point() +facet_wrap(~stage) + geom_smooth(method = "lm")
p
```

**Hint:** You can check the available smoothing methods with
?geom_smooth.

We can also show medians and ranges in various ways:

```{r}
y <- c(18, 11, 16)
df <- data.frame(x = 1:3, y = y, se = c(1.2, 0.5, 1.0))

base <- ggplot(df, aes(x, y, ymin = y - se, ymax = y + se))

```

```{r}
base + geom_crossbar()
```

```{r}
base + geom_pointrange()
```

```{r}
base + geom_errorbar()
```

There are several R packages for adding statistical annotations to plots
(particularly with ggplot2):

**ggpubr**: Adds correlation coefficients, p-values, and other
statistics with functions like stat_cor() easily on ggplot2 plots.
[ggpubr](https://rpkgs.datanovia.com/ggpubr/)

**ggpval**: Automatically performs statistical tests (t-tests, Wilcoxon,
etc.) between groups and annotates p-values on ggplot2 plots.
[ggpval](https://github.com/s6juncheng/ggpval)

**ggstatsplot**: Creates visually informative plots with statistical
details, significance tests, and effect sizes included by default.
[ggstatsplot](https://indrajeetpatil.github.io/ggstatsplot/)

**ggsignif**: Provides an easy way to add significance brackets to
ggplot2 plot. [ggsignif](https://const-ae.github.io/ggsignif/)

Lets add a correlation coefficient to the scatterplot with
expression_1242_at on the x axis and expression_1866_g\_at on the y axis
(with facets by stage).

```{r}
library(ggpubr)
p <- ggplot(data, aes(x = expression_1242_at, y = expression_1866_g_at)) + 
  geom_point() +
  facet_wrap(~stage) +
  stat_cor(method = "pearson")
p
```

## Themes

Many visual aspects of the plots can be adjusted using theme() and
scale_X\_Y() There are various themes already available, but they can
also be tweaked

**ggpubr** package let's you produce publication-ready plots, with
various themes, adding statistics to plots and combining various ggplot
objects into one figure. https://rpkgs.datanovia.com/ggpubr/

**ggsci** package includes scientific journal and Sci-Fi themed color
palettes for ggplot2
https://cran.r-project.org/web/packages/ggsci/vignettes/ggsci.html

We can make our scatterplot a bit nicer.

```{r}
p <- ggplot(data, aes(x = expression_1242_at, y = expression_1866_g_at)) + 
  geom_point() +
  facet_wrap(~stage) +
  stat_cor(method = "pearson")+
  theme_classic2()
p
```

We can save our plots using the *ggsave()* function. The function saves
a single ggplot object to a file (PNG, PDF, SVG, TIFF, etc.) with
customizable size, resolution, and format based on the filename
extension.

```{r}
ggsave("my.first.plot.png", plot = p, width = 12, height = 7)
```

Once you find the best way to visualize the data, you can simply change
the dataset of the ggplot object using the ggplot **%+%** operator

```{r}
p <- ggplot(mtcars, aes(mpg, wt, color=factor(cyl))) + 
  geom_point(shape=20, size=4)
print(p)

p2<-p %+% mtcars[mtcars$disp>200,]
print(p2)
```

For more information and help with making graphs see the [R Graphics
Cookbook](https://r-graphics.org/)

### Exercise

For the **qpcr_ddCt** data set produce plots that visualize: 1.
Comparison of TP53 and MYC expression 2. Comparison of ΔCt values across
control and treated samples
