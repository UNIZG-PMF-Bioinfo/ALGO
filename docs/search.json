[
  {
    "objectID": "00_main_page.html",
    "href": "00_main_page.html",
    "title": "Algorithms and programming course",
    "section": "",
    "text": "👋 Welcome to the Algorithms and programming course\nThis website hosts the material for the Algorithms and programming course. You’ll find R code examples, tasks, and explanations for each week"
  },
  {
    "objectID": "00_main_page.html#running-code",
    "href": "00_main_page.html#running-code",
    "title": "00_main_page",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "Week1/week1_lecture2.html",
    "href": "Week1/week1_lecture2.html",
    "title": "Week 1 - Lecture 2",
    "section": "",
    "text": "myfun <- function(input, parameters) {\ndo a thing\ndo another thing\n…\noutput\n}\nWrite a function\nMake a simple function which will multiplies two numbers.\n\nmySimpleFun <- function(a=1,b) {\n    product <- a*b\n    return(product)\n}\n\nThe function will return whatever is called on the last line, or you can explicitly state it with return().\nExecution i.e. calling a function\n\nmySimpleFun(b=3)\n\n[1] 3\n\nmySimpleFun(a=2, b=3)\n\n[1] 6\n\nmySimpleFun(2, 3)\n\n[1] 6"
  },
  {
    "objectID": "Week1/week1_lecture2.html#global-and-local-variables",
    "href": "Week1/week1_lecture2.html#global-and-local-variables",
    "title": "Week 1 - Lecture 2",
    "section": "Global and local variables",
    "text": "Global and local variables\n\nmySimpleFun <- function(a=1,b) {\n    product <- a*b\n    return(product)\n}\n\nWhat happens with the function if we change variable vol outside it? Nothing! The function has its own local environment.\n\nproduct <- 5\nmySimpleFun(2, 3)\n\n[1] 6\n\nproduct\n\n[1] 5"
  },
  {
    "objectID": "Week1/week1_lecture2.html#function-as-binary-operator",
    "href": "Week1/week1_lecture2.html#function-as-binary-operator",
    "title": "Week 1 - Lecture 2",
    "section": "Function as binary operator",
    "text": "Function as binary operator\nAll functions are beautiful, but not all come in the same shape :)\nAn operator is a function that takes one or two arguments and can be written without parentheses\nfunction(arg1, arg2)\nvs.\narg1 operator arg2\nOperator %in% is used to identify if an element belongs to a vector or dataframe.\n\nc(1,4,2,1) %in% c(2,3)\n\n[1] FALSE FALSE  TRUE FALSE"
  },
  {
    "objectID": "Week1/week1_lecture2.html#multiple-inputs-vectorisation",
    "href": "Week1/week1_lecture2.html#multiple-inputs-vectorisation",
    "title": "Week 1 - Lecture 2",
    "section": "Multiple inputs / vectorisation",
    "text": "Multiple inputs / vectorisation\n\nmySimpleFun(1:3, 3:5)\n\n[1]  3  8 15"
  },
  {
    "objectID": "Week1/week1_lecture2.html#flow-control-if-statement",
    "href": "Week1/week1_lecture2.html#flow-control-if-statement",
    "title": "Week 1 - Lecture 2",
    "section": "Flow control: if statement",
    "text": "Flow control: if statement\nif(condition is fulfilled) {\ndo the thing\n} else {\ndo the other thing\n}\n\nmySimpleFun <- function(a=1,b) {\n    if (a < 0) {\n        a <- (-1)*a\n    } else {\n        a <- a\n    }\n    \n    product <- a*b\n    return(product)\n}"
  },
  {
    "objectID": "Week1/week1_lecture2.html#warnings-errors-and-messages",
    "href": "Week1/week1_lecture2.html#warnings-errors-and-messages",
    "title": "Week 1 - Lecture 2",
    "section": "Warnings, errors and messages",
    "text": "Warnings, errors and messages\nYou are getting the hang of this, and with an additional pair of hands the work is coming along quickly. But after one calculation, you notice the numbers are fishy. Upon closer inspection, you discover that you input thickness with a decimal dot in the wrong place. To prevent this from happening again and going unnoticed, you add a warning():\n\nmySimpleFun <- function(a=1,b) {\n    if (a < 0) {\n        warning(\"First number is negative! Changing it to positive.\")\n        a <- (-1)*a\n    } else {\n        a <- a\n    }\n    \n    product <- a*b\n    return(product)\n}\n\nIf you want the function to stop executing, use break().\nmessage() has similar syntax but different “level of alert”."
  },
  {
    "objectID": "Week1/week1_lecture2.html#multiple-outputs",
    "href": "Week1/week1_lecture2.html#multiple-outputs",
    "title": "Week 1 - Lecture 2",
    "section": "Multiple outputs",
    "text": "Multiple outputs\n\nmySimpleFun <- function(a=1,b) {\n    if (a < 0) {\n        warning(\"First number is negative! Changing it to positive.\")\n        a <- (-1)*a\n    } else {\n        a <- a\n    }\n    # calculate product\n    product <- a*b\n    # make a figure\n    figure <-  plot(c(a,b))\n    # save a list\n    res_list <- list(\"product\"=product, \"figure\"=figure)\n    # return\n    return(res_list)\n}\n## run the fuction\nmySimpleFun(b=-2)\n\n\n\n\n$product\n[1] -2\n\n$figure\nNULL\n\n\nifelse(test, yes, no) - vectorised\n\nmySimpleFun <- function(a=1,b) {\n  # make all negatives positive\n  a <- ifelse(a < 0, -a, a)\n\n  # calculate product\n  product <- a * b\n\n  # (plots will only show the last one in a loop, so you usually don’t do this inside)\n  plot(a, b)   # e.g. scatter plot\n\n  list(product = product)\n}\n\nmySimpleFun(a= c(2,3,2,-1), b=c(3,4,5,2))\n\n\n\n\n$product\n[1]  6 12 10  2\n\n\nTry to change ‘list’ with ‘c’ and see what happens. You have to put multiple outputs together as a list, otherwise it doesn’t work properly!"
  },
  {
    "objectID": "Week1/week1_lecture2.html#looping-in-r",
    "href": "Week1/week1_lecture2.html#looping-in-r",
    "title": "Week 1 - Lecture 2",
    "section": "Looping in R",
    "text": "Looping in R\nfor(each value in sequence) {\ndo the thing\n}\n\nfor(i in 1:5) {\n    print(\"bla\")\n}\n\n[1] \"bla\"\n[1] \"bla\"\n[1] \"bla\"\n[1] \"bla\"\n[1] \"bla\"\n\n\nwhile(condition is true) {\ndo the thing\n}\nrepeat {\nthe thing\nif(condition is true) { break }\n}\nIt’s NEVER a time for a loop in R. Instead, there’s the apply() family of functions:"
  },
  {
    "objectID": "Week1/week1_lecture2.html#apply-family-of-functions",
    "href": "Week1/week1_lecture2.html#apply-family-of-functions",
    "title": "Week 1 - Lecture 2",
    "section": "Apply family of functions",
    "text": "Apply family of functions\nlapply():\n\nlapply(iris[, 1:4], sum)          # preforms a function over each list element\n\n$Sepal.Length\n[1] 876.5\n\n$Sepal.Width\n[1] 458.6\n\n$Petal.Length\n[1] 563.7\n\n$Petal.Width\n[1] 179.9\n\nclass(lapply(iris[, 1:4], sum))   # returns a list\n\n[1] \"list\"\n\n\nNotice the three dots (ellipsis) in function description: lapply(X, FUN, ...)\nAccess list entries explicitly by using function(x):\n\nlapply(iris[, 1:4], function(x) sqrt(x[20:30]))\n\n$Sepal.Length\n [1] 2.258318 2.323790 2.258318 2.144761 2.258318 2.190890 2.236068 2.236068\n [9] 2.280351 2.280351 2.167948\n\n$Sepal.Width\n [1] 1.949359 1.843909 1.923538 1.897367 1.816590 1.843909 1.732051 1.843909\n [9] 1.870829 1.843909 1.788854\n\n$Petal.Length\n [1] 1.224745 1.303840 1.224745 1.000000 1.303840 1.378405 1.264911 1.264911\n [9] 1.224745 1.183216 1.264911\n\n$Petal.Width\n [1] 0.5477226 0.4472136 0.6324555 0.4472136 0.7071068 0.4472136 0.4472136\n [8] 0.6324555 0.4472136 0.4472136 0.4472136"
  },
  {
    "objectID": "Week1/week1_lecture2.html#apply-family-of-functions-1",
    "href": "Week1/week1_lecture2.html#apply-family-of-functions-1",
    "title": "Week 1 - Lecture 2",
    "section": "Apply family of functions",
    "text": "Apply family of functions\nsapply() : lapply, but tries to return simpler data format\n\nsapply(iris[, 1:4], sum)\n\nSepal.Length  Sepal.Width Petal.Length  Petal.Width \n       876.5        458.6        563.7        179.9 \n\nclass(sapply(iris[, 1:4], sum))\n\n[1] \"numeric\""
  },
  {
    "objectID": "Week1/week1_lecture2.html#apply-family-of-functions-2",
    "href": "Week1/week1_lecture2.html#apply-family-of-functions-2",
    "title": "Week 1 - Lecture 2",
    "section": "Apply family of functions",
    "text": "Apply family of functions\napply() : apply function over margins of array (1 for rows, 2 for columns)\n\napply(iris[, 1:4], 1, sum)\n\n  [1] 10.2  9.5  9.4  9.4 10.2 11.4  9.7 10.1  8.9  9.6 10.8 10.0  9.3  8.5 11.2\n [16] 12.0 11.0 10.3 11.5 10.7 10.7 10.7  9.4 10.6 10.3  9.8 10.4 10.4 10.2  9.7\n [31]  9.7 10.7 10.9 11.3  9.7  9.6 10.5 10.0  8.9 10.2 10.1  8.4  9.1 10.7 11.2\n [46]  9.5 10.7  9.4 10.7  9.9 16.3 15.6 16.4 13.1 15.4 14.3 15.9 11.6 15.4 13.2\n [61] 11.5 14.6 13.2 15.1 13.4 15.6 14.6 13.6 14.4 13.1 15.7 14.2 15.2 14.8 14.9\n [76] 15.4 15.8 16.4 14.9 12.8 12.8 12.6 13.6 15.4 14.4 15.5 16.0 14.3 14.0 13.3\n [91] 13.7 15.1 13.6 11.6 13.8 14.1 14.1 14.7 11.7 13.9 18.1 15.5 18.1 16.6 17.5\n[106] 19.3 13.6 18.3 16.8 19.4 16.8 16.3 17.4 15.2 16.1 17.2 16.8 20.4 19.5 14.7\n[121] 18.1 15.3 19.2 15.7 17.8 18.2 15.6 15.8 16.9 17.6 18.2 20.1 17.0 15.7 15.7\n[136] 19.1 17.7 16.8 15.6 17.5 17.8 17.4 15.5 18.2 18.2 17.2 15.7 16.7 17.3 15.8"
  },
  {
    "objectID": "Week1/week1_lecture2.html#apply-family-of-functions-3",
    "href": "Week1/week1_lecture2.html#apply-family-of-functions-3",
    "title": "Week 1 - Lecture 2",
    "section": "Apply family of functions",
    "text": "Apply family of functions\nreplicate() : repeated evaluation of expression; returns an array\n\nreplicate(3, sample(1:10, 5))\n\n     [,1] [,2] [,3]\n[1,]    5    8    6\n[2,]    9    2    9\n[3,]    1    4    3\n[4,]    4    7    2\n[5,]    8   10   10"
  },
  {
    "objectID": "Week1/week1_lecture2.html#take-home-messages-on-writing-your-own-functions",
    "href": "Week1/week1_lecture2.html#take-home-messages-on-writing-your-own-functions",
    "title": "Week 1 - Lecture 2",
    "section": "Take home messages on writing your own functions",
    "text": "Take home messages on writing your own functions\nTake care of the future user of your function - it’ll probably be you.\n\ntidy and clear commands - avoid salami code\ntidy and logical higher structures - avoid spaghetti code\nsensible function and variable names\n(b, bb, bbs, dajproradivise, omg, matfixmerggr)\nCOMMENT YOUR CODE\n\n\n# example of salami code:\nsum(as.numeric(names(table(sample(50:300, 1000, replace=T) %/% 25))))   \n\n[1] 77\n\n\nvs.\n\nmysample <- sample(50:300, 1000, replace=T)\nroundit <- mysample %/% 25\ntb <- table(roundit)\ntb\n\nroundit\n  2   3   4   5   6   7   8   9  10  11  12 \n 89  92  97 101  97 104 103 107  95 109   6 \n\ncategories <- as.numeric(names(tb))\ncategories\n\n [1]  2  3  4  5  6  7  8  9 10 11 12\n\ncat_sum <- sum(categories)\ncat_sum\n\n[1] 77\n\n\nMost importantly, if there is already a function for what you are trying to do, don’t write your own without a good reason. (Homework instructions are a good reason.)"
  },
  {
    "objectID": "Week1/week1_lecture1.html",
    "href": "Week1/week1_lecture1.html",
    "title": "Week 1 - Lecture 1",
    "section": "",
    "text": "homeworks + exam\nMoodle forum\nno copy-pasting, no group work\nNO ChatGPT!!\nstudent participation !!!"
  },
  {
    "objectID": "Week1/week1_lecture1.html#r",
    "href": "Week1/week1_lecture1.html#r",
    "title": "Week 1 - Lecture 1",
    "section": "R",
    "text": "R\n\ntoolbox for statistical analyses and data manipulation\nadvanced, flexible data formats\nuser-friendly\nsimple syntax\npackages\ncommunity: documentation, stackOverflow, Github, Biostars…\n\n\nGoogle. Google. Google."
  },
  {
    "objectID": "Week1/week1_lecture1.html#make-your-r-usage-easier",
    "href": "Week1/week1_lecture1.html#make-your-r-usage-easier",
    "title": "Week 1 - Lecture 1",
    "section": "Make your R usage easier",
    "text": "Make your R usage easier\n\nTips&Tricks\n\nCtrl+Enter to run code/send to console\ntab for auto-complete\nkeyboard shortcuts listed in Help\nHistory: send to console, up arrow\nHelp: search manually or from console (?, ??, example())\nadjust defaults in Global options"
  },
  {
    "objectID": "Week1/week1_lecture1.html#make-your-r-usage-easier-1",
    "href": "Week1/week1_lecture1.html#make-your-r-usage-easier-1",
    "title": "Week 1 - Lecture 1",
    "section": "Make your R usage easier",
    "text": "Make your R usage easier\n\nRmarkdown (https://rmarkdown.rstudio.com/)\n\nvarious outputs for sharing your work (.html, .pdf, Word, website…)\ntext + code chunks\nCtrl+Alt+I to insert new chunk\nchunk options (message, warning, fig…)"
  },
  {
    "objectID": "Week1/week1_lecture1.html#make-your-r-usage-easier-2",
    "href": "Week1/week1_lecture1.html#make-your-r-usage-easier-2",
    "title": "Week 1 - Lecture 1",
    "section": "Make your R usage easier",
    "text": "Make your R usage easier\n\nUser interfaces\n\nRGui - useful when upgrading versions (package installR)\nRStudio - additional functionality, projects"
  },
  {
    "objectID": "Week1/week1_lecture1.html#basic-components",
    "href": "Week1/week1_lecture1.html#basic-components",
    "title": "Week 1 - Lecture 1",
    "section": "Basic components",
    "text": "Basic components\n\nvariables\n\nfunctions\n\nenvironment\n\nFor starters, you can use R as a calculator:\n\n3 + 5\n10/2\n4^2\n8 %/% 3\n8 %% 3\n\n[1] 8\n[1] 5\n[1] 16\n[1] 2\n[1] 2\n\n\nSome basic functions:\n\nround(1.86)\nsqrt(25)\nlog10(1000)\n\n[1] 2\n[1] 5\n[1] 3"
  },
  {
    "objectID": "Week1/week1_lecture1.html#variables",
    "href": "Week1/week1_lecture1.html#variables",
    "title": "Week 1 - Lecture 1",
    "section": "Variables",
    "text": "Variables\n\neverything is a vector\n\nassignment:\n\n<-\n<<-\n\n=\nbut don’t touch the last two!!!\nn <- 5\n\ncreate/collate: c()\n\nview: print() or type name"
  },
  {
    "objectID": "Week1/week1_lecture1.html#vectors",
    "href": "Week1/week1_lecture1.html#vectors",
    "title": "Week 1 - Lecture 1",
    "section": "Vectors",
    "text": "Vectors\n\ncharacter, numeric (integer and double), logical\nclass(), typeof()\nas.x() family of functions\n\nCreate your first variable:\n\nn <- 9\n\nLet’s see it:\n\nn\nprint(n)\nclass(n)\n\n[1] 9\n[1] 9\n[1] \"numeric\"\n\n\nAs we said, every variable in R is a vector. So what does this mean?\nLet’s add one more number to our variable n using function c():\n\nn <- c(n, 16); n\nclass(n)\n\n[1]  9 16\n[1] \"numeric\"\n\n\nHow do functions work on this?\n\nsqrt(n)\n\n[1] 3 4\n\n\nWhat happens when we try to add a letter?\n\nn <- c(n, \"z\"); n\nclass(n)\n\n[1] \"9\"  \"16\" \"z\" \n[1] \"character\"\n\n\nNumeric vector:\n\nn1 <- c(1,2,4); n1\nas.character(n1)\n\n[1] 1 2 4\n[1] \"1\" \"2\" \"4\"\n\n\nCreate sequential numeric vector:\n\nn2 <- 1:10; n2\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nCharacter vector:\n\nch <- c(\"a\", \"b\", \"c\", \"d\", \"spanishinquisition\"); ch\n\n[1] \"a\"                  \"b\"                  \"c\"                 \n[4] \"d\"                  \"spanishinquisition\""
  },
  {
    "objectID": "Week1/week1_lecture1.html#boolean-variable",
    "href": "Week1/week1_lecture1.html#boolean-variable",
    "title": "Week 1 - Lecture 1",
    "section": "Boolean variable",
    "text": "Boolean variable\nTRUE FALSE\nIt is a binary variable.\n\nbool <- c(T,F,T,T,F); bool\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n\nas.numeric(bool)\n\n[1] 1 0 1 1 0\n\nbin <- c(0,1,1,0,1); bin\n\n[1] 0 1 1 0 1\n\nclass(bin)\n\n[1] \"numeric\"\n\nas.logical(bin)\n\n[1] FALSE  TRUE  TRUE FALSE  TRUE"
  },
  {
    "objectID": "Week1/week1_lecture1.html#boolean-operators",
    "href": "Week1/week1_lecture1.html#boolean-operators",
    "title": "Week 1 - Lecture 1",
    "section": "Boolean operators",
    "text": "Boolean operators\n\nAND &\nOR |\nNOT !\n\n\nprint(bool)\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n\nprint(bin)\n\n[1] 0 1 1 0 1\n\n\n\n& and | are vectorised\n&& and || are short-circuited\n\n\nbool & bin\nbool && bin\n\n\nbool | bin\nbool || bin\n\n\n!bool\n!bool || bin\n\n\nComparison operators\n==\n!=\n>\n>=\n<\n<=\n\nn2\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nn2 == 2\n\n [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\nn2 > 5\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nn2 >= 5\n\n [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\n\n\nComparison operators\n\nbool\nbin\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n[1] 0 1 1 0 1\n\n\n\nbool == bin\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\nbool != bin\n\n[1]  TRUE  TRUE FALSE  TRUE  TRUE\n\n\n\n\nRECYCLING\nWhat happens when vectors are not the same length?\n\nn1; n2\n\n[1] 1 2 4\n\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nn2*c(2,3)\n\n [1]  2  6  6 12 10 18 14 24 18 30\n\n\n\nn2*n1\n\nWarning in n2 * n1: longer object length is not a multiple of shorter object\nlength\n\nn2 == n1\n\nWarning in n2 == n1: longer object length is not a multiple of shorter object\nlength\n\n\n [1]  1  4 12  4 10 24  7 16 36 10\n [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE"
  },
  {
    "objectID": "Week1/week1_lecture1.html#basic-functions",
    "href": "Week1/week1_lecture1.html#basic-functions",
    "title": "Week 1 - Lecture 1",
    "section": "Basic functions",
    "text": "Basic functions\nlength() : how many elements in a vector\n\nmyvec <- 1:20\nlength(myvec)\n\n[1] 20\n\n\n\nlength(\"banana\")\nnchar(\"banana\")\n\n[1] 1\n[1] 6\n\n\nwhich() : returns positions of elements which satisfy the condition\n\nwhich(n1 == 4)\nwhich((myvec<=2) | (myvec>17))\n\n[1] 3\n[1]  1  2 18 19 20"
  },
  {
    "objectID": "Week1/week1_lecture1.html#basic-functions-1",
    "href": "Week1/week1_lecture1.html#basic-functions-1",
    "title": "Week 1 - Lecture 1",
    "section": "Basic functions",
    "text": "Basic functions\nnames() : gives names to the elements\n\nnames(ch) <- c(\"letter\", \"letter\", \"letter\", \"anotherletter\", \"nobodyexpected\")\nch\n\n              letter               letter               letter \n                 \"a\"                  \"b\"                  \"c\" \n       anotherletter       nobodyexpected \n                 \"d\" \"spanishinquisition\" \n\n\n%in% operator - are elements of the first vector present in the second vector?\n\nn2 %in% n1 \n\n [1]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE"
  },
  {
    "objectID": "Week1/week1_lecture1.html#basic-functions-2",
    "href": "Week1/week1_lecture1.html#basic-functions-2",
    "title": "Week 1 - Lecture 1",
    "section": "Basic functions",
    "text": "Basic functions\nunique() : returns unique elements\n\nn3 <- c(0,0,0,0,1,1,1,2,2,2,2,2,3,3,3,3,5)\nunique(n3)\n\n[1] 0 1 2 3 5\n\n\nduplicated() : logical: did the same element appear before in the vector?\n\nduplicated(n3)\nduplicated(c(5, n3))\n\n [1] FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n[13] FALSE  TRUE  TRUE  TRUE FALSE\n [1] FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE  TRUE FALSE  TRUE  TRUE  TRUE\n[13]  TRUE FALSE  TRUE  TRUE  TRUE  TRUE\n\n\ntable() : how many times does each unique element appear\n\ntable(n3)\n\nn3\n0 1 2 3 5 \n4 3 5 4 1 \n\n\nGet just the frequencies from table:\n\nn3\nas.numeric(table(n3))\n\n [1] 0 0 0 0 1 1 1 2 2 2 2 2 3 3 3 3 5\n[1] 4 3 5 4 1\n\n\nGet unique elements using names - but be careful!\n\nnames(table(n3))\nclass(names(table(n3)))\n\n[1] \"0\" \"1\" \"2\" \"3\" \"5\"\n[1] \"character\"\n\n\n\nTaking a sample\nsample() : take a sample from vector\n\nsample(n3, 4)\nsample(n3, 25, replace=TRUE)\n\n[1] 1 1 2 2\n [1] 1 3 3 3 3 2 3 1 3 3 5 0 3 2 3 0 1 0 0 0 1 2 3 3 0\n\n\nTake a sample from some basic distributions: \n\nsample(1:100, size = 10)\nrunif(10, min=1, max=100)\ns <- rnorm(20, mean=3, sd=0.7); s\n\n [1] 62 67 16 68 26 24 92 44 88 96\n [1] 96.041517 66.758571  9.026198 16.081324 34.776095 43.891385 36.276125\n [8] 45.725790 59.153096 28.156006\n [1] 2.452289 3.428813 2.298833 3.498484 3.189722 3.060816 3.091299 2.592480\n [9] 2.377535 2.659415 3.815378 3.086934 2.620943 3.547611 3.901228 2.643391\n[17] 2.823681 3.576900 2.167666 3.663854\n\n\n\n\nGenerating sequences\nseq()\n\nseq(from=1, to=100, by=2)\nseq(from=0, to=10, length.out=21)\n\n [1]  1  3  5  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49\n[26] 51 53 55 57 59 61 63 65 67 69 71 73 75 77 79 81 83 85 87 89 91 93 95 97 99\n [1]  0.0  0.5  1.0  1.5  2.0  2.5  3.0  3.5  4.0  4.5  5.0  5.5  6.0  6.5  7.0\n[16]  7.5  8.0  8.5  9.0  9.5 10.0\n\n\nrep()\n\nrep(1:3, times=4)\nrep(1:3, each=4)\n\n [1] 1 2 3 1 2 3 1 2 3 1 2 3\n [1] 1 1 1 1 2 2 2 2 3 3 3 3\n\n\ndon’t mix up rep() and replicate()!\n\nreplicate(n = 10, expr = mean(sample(x = 1:10, size = 3)) )\n\n [1] 7.000000 6.000000 5.000000 7.333333 3.666667 3.666667 7.333333 6.666667\n [9] 6.333333 3.000000\n\n\n\n\nBasic statistics\n\nmean(s)\n\n[1] 3.024863\n\nsd(s)\n\n[1] 0.5371422\n\nquantile(s)\n\n      0%      25%      50%      75%     100% \n2.167666 2.613827 3.073875 3.510765 3.901228"
  },
  {
    "objectID": "Week1/week1_lecture1.html#vector-subsetting",
    "href": "Week1/week1_lecture1.html#vector-subsetting",
    "title": "Week 1 - Lecture 1",
    "section": "Vector subsetting []",
    "text": "Vector subsetting []\n\nby position\nby condition\n\nOne position:\n\nn1[3] \n\n[1] 4\n\n\nMultiple positions:\n\nn2[1:5]\nch[c(2,4,5)]\n\n[1] 1 2 3 4 5\n              letter        anotherletter       nobodyexpected \n                 \"b\"                  \"d\" \"spanishinquisition\" \n\n\nEverything except 1 position:\n\nn2[-7]\n\n[1]  1  2  3  4  5  6  8  9 10\n\n\nPositions stored in another vector:\n\nn2[n1]\n\n[1] 1 2 4"
  },
  {
    "objectID": "Week1/week1_lecture1.html#vector-subsetting-1",
    "href": "Week1/week1_lecture1.html#vector-subsetting-1",
    "title": "Week 1 - Lecture 1",
    "section": "Vector subsetting []",
    "text": "Vector subsetting []\n\nby position\nby condition\n\n\nn2\nn2 > 5\nn2[n2 > 5]\n\n [1]  1  2  3  4  5  6  7  8  9 10\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n[1]  6  7  8  9 10\n\n\n\nbin\nn2[bin]\nn2[as.logical(bin)]\n\n[1] 0 1 1 0 1\n[1] 1 1 1\n[1]  2  3  5  7  8 10\n\n\n\nExercise 1\nCreate a vector myvec which contains all numbers from 1 to 20 except 3 and 6. Subset fifth and fourth number by position.\n\n\nExercise 2\nSubset myvec to get only numbers smaller or equal to 2 or larger than 17. Return first the numbers, then their positions in the original vector.\nSubset myvec to return only elements which are in positions divisible by 3.\n\n\nExercise 3\nReturn words from vector ch which have more than 5 letters."
  },
  {
    "objectID": "Week1/week1_lecture1.html#data-structures",
    "href": "Week1/week1_lecture1.html#data-structures",
    "title": "Week 1 - Lecture 1",
    "section": "Data structures",
    "text": "Data structures\n- vectors  \n- factors = vectors with (unchangeable) levels  \n- matrices = dataframes with 1 type of data  \n- lists  \n- data frames = pretty lists"
  },
  {
    "objectID": "Week1/week1_lecture1.html#factors",
    "href": "Week1/week1_lecture1.html#factors",
    "title": "Week 1 - Lecture 1",
    "section": "Factors",
    "text": "Factors\nVectors with predefined levels.\nUsual suspects for your errors.\n\nfac <- factor(n3); fac\n\n [1] 0 0 0 0 1 1 1 2 2 2 2 2 3 3 3 3 5\nLevels: 0 1 2 3 5\n\n\n\nfac[1] <- 6\n\nWarning in `[<-.factor`(`*tmp*`, 1, value = 6): invalid factor level, NA\ngenerated\n\nfac\n\n [1] <NA> 0    0    0    1    1    1    2    2    2    2    2    3    3    3   \n[16] 3    5   \nLevels: 0 1 2 3 5\n\n\nSo how to turn a factor into normal numeric vector? There’s a hack.\n\nas.numeric(fac)\nas.numeric(as.character(fac))\n\n [1] NA  1  1  1  2  2  2  3  3  3  3  3  4  4  4  4  5\n [1] NA  0  0  0  1  1  1  2  2  2  2  2  3  3  3  3  5"
  },
  {
    "objectID": "Week1/week1_lecture1.html#matrices",
    "href": "Week1/week1_lecture1.html#matrices",
    "title": "Week 1 - Lecture 1",
    "section": "Matrices",
    "text": "Matrices\n\nm <- matrix(1:15, nrow=5, ncol=3); m\n\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n\n\nSubsetting:\n\nm[1,3]\nm[12]\nm[,2]\n\n[1] 11\n[1] 12\n[1]  6  7  8  9 10\n\n\nBasic functions:\n\nt(m)      # transpose\ndiag(m)   # extract diagonal\ndim(m)    # see dimensions\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   10\n[3,]   11   12   13   14   15\n[1]  1  7 13\n[1] 5 3\n\n\n\nExercise 4\nMake a 4x4 matrix m2 with numbers from 1 to 16. Let the first row be: 1 2 3 4 (hint: consult help with ?matrix).\nChange all the numbers on the diagonal to zeroes.\nSum the elements in each row."
  },
  {
    "objectID": "Week1/week1_lecture1.html#lists",
    "href": "Week1/week1_lecture1.html#lists",
    "title": "Week 1 - Lecture 1",
    "section": "Lists",
    "text": "Lists\nStore anything; most flexible data type.\n\nl <- list(n2, bool, m, fac); l\n\n[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10\n\n[[2]]\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n\n[[3]]\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n\n[[4]]\n [1] <NA> 0    0    0    1    1    1    2    2    2    2    2    3    3    3   \n[16] 3    5   \nLevels: 0 1 2 3 5"
  },
  {
    "objectID": "Week1/week1_lecture1.html#lists-1",
    "href": "Week1/week1_lecture1.html#lists-1",
    "title": "Week 1 - Lecture 1",
    "section": "Lists",
    "text": "Lists\nLet’s name the entries:\n\nnames(l) <- c(\"vector1\", \"vector2\", \"matrix1\", \"factor1\")\n\nHow many entries?\n\nlength(l)\n\n[1] 4\n\n\nHow about dimensions?\n\ndim(l)\n\nNULL\n\n\n\nList subsetting\nBy position:\n\nl[2]\nclass(l[2])\n\n$vector2\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n\n[1] \"list\"\n\n\nBy position, another way:\n\nl[[4]]\nclass(l[[4]])\n\n [1] <NA> 0    0    0    1    1    1    2    2    2    2    2    3    3    3   \n[16] 3    5   \nLevels: 0 1 2 3 5\n[1] \"factor\"\n\n\nBy name:\n\nl$vector2\nclass(l$vector2)\nl[[\"factor1\"]]\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE\n[1] \"logical\"\n [1] <NA> 0    0    0    1    1    1    2    2    2    2    2    3    3    3   \n[16] 3    5   \nLevels: 0 1 2 3 5\n\n\nSubset an element of an element:\n\nunlist(l[2])\n\nvector21 vector22 vector23 vector24 vector25 \n    TRUE    FALSE     TRUE     TRUE    FALSE \n\nclass(unlist(l[2]))\n\n[1] \"logical\"\n\nl[3]\n\n$matrix1\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n\nl[[3]][2,3]\n\n[1] 12\n\n#l[3][2,3]"
  },
  {
    "objectID": "Week1/week1_lecture1.html#data-frames",
    "href": "Week1/week1_lecture1.html#data-frames",
    "title": "Week 1 - Lecture 1",
    "section": "Data frames",
    "text": "Data frames\n“Matrices” with different types of data.\n\ndf <- data.frame(m, ch); df\n\n\n\n  \n\n\ndim(df)\n\n[1] 5 4\n\nncol(df); nrow(df)\n\n[1] 4\n\n\n[1] 5\n\ncolnames(df); rownames(df)\n\n[1] \"X1\" \"X2\" \"X3\" \"ch\"\n\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\n\n\nData frame subsetting\nBy position:\n\ndf[2, 3]\ndf[, 3:4]\n\n[1] 12\n\n\n\n\n  \n\n\n\nBy names:\n\ndf[\"ch\"]\ndf$ch\nclass(df[\"ch\"])\nclass(df$ch)\n\n\n\n  \n\n\n\n[1] \"a\"                  \"b\"                  \"c\"                 \n[4] \"d\"                  \"spanishinquisition\"\n[1] \"data.frame\"\n[1] \"character\"\n\n\nInternally, data frames are lists with entries of equal lengths."
  },
  {
    "objectID": "Week1/week1_lecture1.html#data-frames-1",
    "href": "Week1/week1_lecture1.html#data-frames-1",
    "title": "Week 1 - Lecture 1",
    "section": "Data frames",
    "text": "Data frames\nAdding a column:\n\ndf <- cbind(df, bool); df\n\n\n\n  \n\n\n\nRemoving a column:\n\ndf[\"bool\"] <- NULL; df\n\n\n\n  \n\n\n\nRemoving a row:\n\n#df[5, ] <- NULL; df\n\ndf <- df[-5, ]\n\n\nExercise 5\nR has a number of pre-loaded datasets, iris probably being the most famous one.\nLoad iris and calculate mean length of sepal."
  },
  {
    "objectID": "Week2/week2_part0.html",
    "href": "Week2/week2_part0.html",
    "title": "R packages",
    "section": "",
    "text": "CRAN is the official repository for R packages. It hosts thousands of stable, peer-reviewed R packages that have passed strict checks for quality and compatibility.\n\n#Install from CRAN as follow:\ninstall.packages(\"magrittr\")\ninstall.packages(\"dplyr\")\ninstall.packages(\"ggplot2\") \n\n\n\n\nGitHub is a platform for code sharing and collaboration, widely used by developers. Many R package authors share their development versions on GitHub—these might include the newest features or bug fixes that haven’t yet been submitted to CRAN.\n\n#Or, install the latest version from GitHub as follow:\n# Install\nif(!require(devtools)) install.packages(\"devtools\")\ndevtools::install_github(\"kassambara/ggpubr\")\n\n\n\n\nBioconductor is a specialized repository for packages focused on bioinformatics, genomics, and computational biology. It includes tools for analyzing DNA/RNA sequencing, gene expression, and other biological data.\n\n## Bioconductor\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(\"airway\")"
  },
  {
    "objectID": "Week2/week2_part0.html#load-the-packages",
    "href": "Week2/week2_part0.html#load-the-packages",
    "title": "R packages",
    "section": "Load the packages",
    "text": "Load the packages\nWhen you install a package in R (using install.packages() or similar), you’re downloading it and saving it to your computer. This only needs to be done once (per R environment).\nHowever, to use the functions or data from a package in your current R session, you must load the package with library() or require().\n\nlibrary(\"magrittr\")\nlibrary(\"data.table\")\nlibrary(\"ggpubr\")\n\n\nPipes ( %>% )\nPackage magrittr provides a new “pipe”-like operator, %>%. The pipe operator allows you to pipe a value forward into a function. For example you can write vec %>% sum instead of sum(vec) . It makes your code more intuitive to read and write especially when “pipping/chaining” multiple arguments.\n\nsample(x = 1:1000, size = 40) %>% \n   # Call function sum on the whole vector"
  },
  {
    "objectID": "Week2/week2_part1.html",
    "href": "Week2/week2_part1.html",
    "title": "Table manipulation",
    "section": "",
    "text": "A data.frame is a 2D table-like structure where columns can hold different data types. data.table is an enhanced version of data.frame that provides faster and more memory-efficient operations.\n\n\n\n\n\n\nBuilt-in datasets\n\n\n\n\nR comes with several built-in datasets that are useful for learning, testing, and demonstrating functions without needing to load external data.\nThese datasets are included in base R and standard packages like datasets, and can be accessed directly by name (e.g., CO2, iris, mtcars, etc.).\n\n\n\nWe will be working with build-in dataset iris introduced by Ronald Fisher in his 1936 paper The use of multiple measurements in taxonomic problems, contains three plant species (setosa, virginica, versicolor) and four features measured for each sample.\nLet’s examine the first six rows of the table!\n\n# Call the table\nhead(iris) \n\n\n\n  \n\n\n\n\n\n\n\n\n\n\n\nFeature\ndata.frame\ndata.table\n\n\n\n\nBase structure\nBase R object\nExtension of data.frame\n\n\nSpeed\nModerate\nVery fast, optimized for large data\n\n\nSyntax\nVerbose\nConcise and powerful\n\n\nRownames\nSupported\nDiscouraged / ignored\n\n\nMemory usage\nStandard\nMore memory-efficient\n\n\nGrouping\nUses aggregate() or dplyr\nBuilt-in with by=\n\n\nJoining\nUses merge()\nFast joins with keys (setkey())\n\n\nLearning curve\nLow (familiar to most R users)\nMedium (different syntax)\n\n\n\n\n\n\n\n\n\n\n\nFunctions to import the data\n\n\n\n\nbasic R import function:\ndf <- read.csv()\ndf <- read.tsv()\ndf <- read.table()\ndata.table import function:\ndt <- fread()\nusing specialized funcions from R packages to import files such as Excel, SPSS\ndf <- read_excel()\ndf <- read.spss()\n..."
  },
  {
    "objectID": "Week2/week2_part1.html#how-to-obtain-data.table",
    "href": "Week2/week2_part1.html#how-to-obtain-data.table",
    "title": "Table manipulation",
    "section": "How to obtain data.table?",
    "text": "How to obtain data.table?\n\n\n\n\n\n\nImport as data.table or convert existing formats to data.table\n\n\n\n\nImport data using function fread().\n\ndt_import <- fread(\"PATH/TO/FILE\")\n\nConvert data.frame (even other objects such as matrices, GRanges object…) using as.data.table().\n\ndt_import <- as.data.table(df)\n\nAnother approach of converting object to data.table using setDT() but without defining the new variable.\n\nsetDT(df)\n\n\n\n\n\n\n\n\nTip\n\n\n\nA file path tells R where to find or save a file.\n\nAbsolute path: The full location starting from the root of your computer.\n\nExample: \"C:/Users/Paula/Documents/data.csv\"\n\nRelative path: A shortcut from the current working directory.\n\nExample: \"data/data.csv\"\n\n\nUse getwd() to check your current working directory.\n💡 Tip: In RStudio Projects, use relative paths so your code works on any computer."
  },
  {
    "objectID": "Week2/week2_part1.html#from-data.frame-to-data.table",
    "href": "Week2/week2_part1.html#from-data.frame-to-data.table",
    "title": "Table manipulation",
    "section": "From data.frame to data.table",
    "text": "From data.frame to data.table\nRun the code chunk below. If you want, check it out using rownames().\n\n( df_letters <- data.frame( one=1:6, two=2:7, row.names=letters[1:6]) )\n\n\n\n  \n\n\n( dt_letters <- as.data.table(df_letters) )\n\n\n\n  \n\n\n\n\nHow to keep the rownames?\nSet argument keep.rownames to TRUE if you want to keep the rownames as a separate column in data.table.\n\n( dt_letters <- as.data.table(df_letters, keep.rownames=TRUE) )\n\n\n\n  \n\n\n\nInstead of keep.rownames=TRUE, you can specify the name of the column containing the rownames from the data.frame.\nExample:\n\n( dt_letters <- as.data.table(df_letters, keep.rownames=\"letters\") )\n\n\n\n  \n\n\n\n\nTask example: Convert iris to data table using as.data.table\nCreate a variable iris_dt that contains iris data set as data.table object. In this tutorial we are going to compare and analyze the default data set iris as data frame and data table objects.\n\niris_dt <- as.data.table(iris)\n\n\niris\n\n\n\n  \n\n\nrownames(iris)\n\n  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"5\"   \"6\"   \"7\"   \"8\"   \"9\"   \"10\"  \"11\"  \"12\" \n [13] \"13\"  \"14\"  \"15\"  \"16\"  \"17\"  \"18\"  \"19\"  \"20\"  \"21\"  \"22\"  \"23\"  \"24\" \n [25] \"25\"  \"26\"  \"27\"  \"28\"  \"29\"  \"30\"  \"31\"  \"32\"  \"33\"  \"34\"  \"35\"  \"36\" \n [37] \"37\"  \"38\"  \"39\"  \"40\"  \"41\"  \"42\"  \"43\"  \"44\"  \"45\"  \"46\"  \"47\"  \"48\" \n [49] \"49\"  \"50\"  \"51\"  \"52\"  \"53\"  \"54\"  \"55\"  \"56\"  \"57\"  \"58\"  \"59\"  \"60\" \n [61] \"61\"  \"62\"  \"63\"  \"64\"  \"65\"  \"66\"  \"67\"  \"68\"  \"69\"  \"70\"  \"71\"  \"72\" \n [73] \"73\"  \"74\"  \"75\"  \"76\"  \"77\"  \"78\"  \"79\"  \"80\"  \"81\"  \"82\"  \"83\"  \"84\" \n [85] \"85\"  \"86\"  \"87\"  \"88\"  \"89\"  \"90\"  \"91\"  \"92\"  \"93\"  \"94\"  \"95\"  \"96\" \n [97] \"97\"  \"98\"  \"99\"  \"100\" \"101\" \"102\" \"103\" \"104\" \"105\" \"106\" \"107\" \"108\"\n[109] \"109\" \"110\" \"111\" \"112\" \"113\" \"114\" \"115\" \"116\" \"117\" \"118\" \"119\" \"120\"\n[121] \"121\" \"122\" \"123\" \"124\" \"125\" \"126\" \"127\" \"128\" \"129\" \"130\" \"131\" \"132\"\n[133] \"133\" \"134\" \"135\" \"136\" \"137\" \"138\" \"139\" \"140\" \"141\" \"142\" \"143\" \"144\"\n[145] \"145\" \"146\" \"147\" \"148\" \"149\" \"150\"\n\nrownames(iris_dt)\n\n  [1] \"1\"   \"2\"   \"3\"   \"4\"   \"5\"   \"6\"   \"7\"   \"8\"   \"9\"   \"10\"  \"11\"  \"12\" \n [13] \"13\"  \"14\"  \"15\"  \"16\"  \"17\"  \"18\"  \"19\"  \"20\"  \"21\"  \"22\"  \"23\"  \"24\" \n [25] \"25\"  \"26\"  \"27\"  \"28\"  \"29\"  \"30\"  \"31\"  \"32\"  \"33\"  \"34\"  \"35\"  \"36\" \n [37] \"37\"  \"38\"  \"39\"  \"40\"  \"41\"  \"42\"  \"43\"  \"44\"  \"45\"  \"46\"  \"47\"  \"48\" \n [49] \"49\"  \"50\"  \"51\"  \"52\"  \"53\"  \"54\"  \"55\"  \"56\"  \"57\"  \"58\"  \"59\"  \"60\" \n [61] \"61\"  \"62\"  \"63\"  \"64\"  \"65\"  \"66\"  \"67\"  \"68\"  \"69\"  \"70\"  \"71\"  \"72\" \n [73] \"73\"  \"74\"  \"75\"  \"76\"  \"77\"  \"78\"  \"79\"  \"80\"  \"81\"  \"82\"  \"83\"  \"84\" \n [85] \"85\"  \"86\"  \"87\"  \"88\"  \"89\"  \"90\"  \"91\"  \"92\"  \"93\"  \"94\"  \"95\"  \"96\" \n [97] \"97\"  \"98\"  \"99\"  \"100\" \"101\" \"102\" \"103\" \"104\" \"105\" \"106\" \"107\" \"108\"\n[109] \"109\" \"110\" \"111\" \"112\" \"113\" \"114\" \"115\" \"116\" \"117\" \"118\" \"119\" \"120\"\n[121] \"121\" \"122\" \"123\" \"124\" \"125\" \"126\" \"127\" \"128\" \"129\" \"130\" \"131\" \"132\"\n[133] \"133\" \"134\" \"135\" \"136\" \"137\" \"138\" \"139\" \"140\" \"141\" \"142\" \"143\" \"144\"\n[145] \"145\" \"146\" \"147\" \"148\" \"149\" \"150\""
  },
  {
    "objectID": "Week2/week2_part1.html#row-subsetting",
    "href": "Week2/week2_part1.html#row-subsetting",
    "title": "Table manipulation",
    "section": "Row subsetting",
    "text": "Row subsetting\n\nSyntax comparison\n\n\n\n\n\n\n\n\nOperation\ndata.frame\n_data.table_\n\n\n\n\nSubseting rows\ndf[1:20, ]\ndf[1:20]\n\n\nSubseting rows based on criteria\ndf[df$id < 4, ]\ndf[id < 4]\n\n\n\n\nTask\nSelect all rows in iris_dt with Sepal.Length less than 6.7 and Petal.Length less than 1.2.\n\n# Write the solution here\n\nSelect only setosa species with more than 0.3 Petal.Width.\n\n# Write the solution here"
  },
  {
    "objectID": "Week2/week2_part1.html#column-subsetting",
    "href": "Week2/week2_part1.html#column-subsetting",
    "title": "Table manipulation",
    "section": "Column subsetting",
    "text": "Column subsetting\n\nSyntax comparison\n\n\n\n\n\n\n\n\nOperation\ndata.frame\n_data.table_\n\n\n\n\nSubseting columns\ndf[, c(1,5)]\ndf[, c(1,5)]\n\n\nSubseting columns based on colnames\ndf[, c(\"id\")]\ndf[,.(id)]\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nData.table does not use c() but .() which represents list\n\n\n\nTask\nSelect columns Petal.Length and Petal.Width and first 3 rows\n\n\n\n\n\n\nAdditional methods of subsetting columns in data.table\n\n\n\n\n\n\nTip\n\n\n\n\nUsing a character vector of column names\n\nYou can store column names in a vector and use .. to evaluate it inside data.table.\n\ncnames <- c(\"Petal.Length\", \"Petal.Width\")\n\niris_dt[1:3, ..cnames]\n\n\n\n  \n\n\n\n\nUsing a range of column names\n\nYou can select a range of columns using the : operator between two column names.\n\niris_dt[1:3, Sepal.Length:Petal.Width]\n\n\n\n  \n\n\n\n\nNegative subsetting to exclude columns\n\nUse -() or !() to exclude a range of columns.\n\niris_dt[1:3, -(Sepal.Length:Petal.Width)]\n\n\n\n  \n\n\niris_dt[1:3, !(Sepal.Length:Petal.Length)]\n\n\n\n  \n\n\n\nNote: Sepal.Length:Petal.Width works only in column context—it is not the same as numeric indexing.\n\n\n\nTask\nSelect all rows in iris_dt with Sepal.Width equal to 3.0, but show only columns for Species and Sepal.Width (Do it by using column names!). You may also try other methods of subsetting.\n\n# Write the solution here"
  },
  {
    "objectID": "Week2/week2_part1.html#operation-on-columns",
    "href": "Week2/week2_part1.html#operation-on-columns",
    "title": "Table manipulation",
    "section": "Operation on columns",
    "text": "Operation on columns\n\nSyntax comparison\n\n\n\n\n\n\n\n\nOperation\ndata.frame\ndata.table\n\n\n\n\nCalculate sum\nsum(df$id)\ndf[, sum(id)]\n\n\nCalculate sum by group\nby(df$id, df$group, sum)\ndf[, sum(id), by=group]\n\n\nCalling column out as a vector\ndf$id\ndf[, id]\n\n\n\nCalculate mean of Sepal.Width for all species.\n\niris_dt[, mean(Sepal.Width)]\n\n[1] 3.057333\n\n\nCalculate mean of Sepal.Width for and for each species\n\niris_dt[, mean(Sepal.Width), by=Species] \n\n\n\n  \n\n\n\nAlso the following syntax works for data.table because in the third part it is always the group operation when calculating something per rows: iris_dt[, mean(Sepal.Width), Species]\n\n\n\n\n\n\nAdding the column immediately when performing the operation in data.table\n\n\n\nSyntax: df[, .(new_col = sum(id) ), by=group]\nExample:\n\niris_dt[, .( mean_col = mean(Sepal.Width) ), by=Species]\n\n\n\n  \n\n\n\n\n\n\n\nThe power of data.table over data.frame\ndata.table offers an elegant and efficient way to perform multiple calculations on columns and save the results — all in a concise syntax.\nExample: Calculate mean, standard deviation, max, min, and count of Sepal.Width by Species, then order by mean. ::: callout-important With data.table, you can chain multiple operations using square brackets [], similar in spirit to the dplyr pipe %>%. :::\n\n\n\n\n\n\n\ndata.frame\ndata.table\n\n\n\n\nmeanic <- by(iris$Sepal.Width,INDICES = iris$Species, mean) sdic <- by(iris$Sepal.Width,INDICES = iris$Species, sd) maxx <- by(iris$Sepal.Width,INDICES = iris$Species, max) minx <- by(iris$Sepal.Width,INDICES = iris$Species, min)\nres_df <- data.frame(as.numeric(meanic), as.numeric(sdic), as.numeric(maxx), as.numeric(minx))\nres_df[order(res_df$as.numeric.meanic.),]\niris_dt[ , .(mean=mean(Sepal.Width), sd=sd(Sepal.Width), min_x= min(Sepal.Width), max_x= max(Sepal.Width)), by=Species][order(mean)]\n\n\n\n\nOutput example\n\niris_dt[ , \n        .(mean=mean(Sepal.Width),\n          sd=sd(Sepal.Width),\n          min_x= min(Sepal.Width),\n          max_x= max(Sepal.Width)),\n        by=Species][order(mean)]\n\n\n\n  \n\n\n\n\nTask\nSelect all rows where Sepal.Length < 6.7 and flower species virginica and calculate mean Petal.Width in iris_dt. Do it with and without chaining.\nWith chaining\n\n# Write the solution here\n\nNo chaining\n\n# Write the solution here\n\n\n\n\nAdding new permanent columns\nAdding one columns in data table is done with := and multiple columns with ‘:=’.\nHere is a new column that contains the maximal sepal width for each species was added.\n\niris_dt[, max_width1 := max(Sepal.Width), Species]\niris_dt[1:3]\n\n\n\n  \n\n\n\nAddition of multiple columns.\n\niris_dt[, \":=\" (max_width2 = max(Sepal.Width),  \n                max_width3 = max(Sepal.Length) ),\n        by=.(Species)]\niris_dt[1:3]\n\n\n\n  \n\n\n\n\nTask: Add a new column\nAdd columns to iris_dt that represent mean and sd of Petal.Width grouped by species. Columns are called meanPW and sdPW.\n\n# Write the solution here\n\nUse function uniqueN() to check how many unique mean Petal.Width there are in total and by Species group.\n\n# Write the solution here\n\n\n\n\nSpecial symbols in data.table\n.N (an integer containing the number of rows in the group)\n\niris_dt[, .N]\n\n[1] 150\n\n\nCan be used on groups. What is happening here with this subsetting in group?\n\niris_dt[, .N, by=.(Species, Sepal.Length>=4.8)]\n\n\n\n  \n\n\n\n.I (vector representing the row number)\n\niris_dt[, .(row_id=.I, Species)]\n\n\n\n  \n\n\n\nWarning! It does not assign unique row ID based on specified group!\n\niris_dt[, .(row_id=.I), by=Species][c(1,51,101)]\n\n\n\n  \n\n\n\n.GRP (an integer containing a simple group counter)\n\niris_dt[,.GRP, by=.(Species, Petal.Width>=2)]\n\n\n\n  \n\n\n\n\nExercise: :=, .N, .I, .GRP\nAdd columns to iris_dt that represent the number of observations, row number, and group ID of all rows for which Petal.Length is smaller than 6.5, grouped by Species.\n\n# Write the solution here\n\nMoreover, show only the newly added columns in your final results and use na.omit() to remove all missing values from your table\n\n# Write the solution here\n\nOne great benefit of data.table is the ability to sub-assign by reference: Try it: select all rows that have species==“virginica” and rename those Species entries using := to new_virginica.\n\n# Write the solution here\n\n\n\nData.table special {}\nSuppressing Intermediate Output with {} is useful when you have to perform multiple consecutive calculations. Instead of adding column after a column that contains each step you can use {} to get only the final outcome and not all the intermediate steps.\n\nExample\nCreate a new variable sepal_length_diff as the difference from mean value of Sepal.Length and use function round() to round the result to one decimal\n\niris_dt[, sepal_length_diff := {\n  mean_sepal_length = mean(Sepal.Length)\n  diff_from_avg = Sepal.Length - mean_sepal_length\n  round(diff_from_avg, 1)\n}]\n\niris_dt[, .(sepal_length_diff)]\n\n\n\n  \n\n\n\n\n\nExample\nAdd two new columns to iris_dt, grouped by Species:\nsepal_length_diff – the difference between each observation’s Sepal.Length and the group mean of Sepal.Length, rounded to one decimal.\nmean_diff – the mean of these differences within each group (which should be approximately zero).\nUse {} inside data.table to perform intermediate calculations and return both results in one step.\n\niris_dt[, c(\"sepal_length_diff\", \"mean_diff\") := {\n  mean_sepal_length <- mean(Sepal.Length)\n  diff_from_avg <- Sepal.Length - mean_sepal_length\n  .(round(diff_from_avg, 1), mean(diff_from_avg))\n}, by = Species]\n\niris_dt[, .(sepal_length_diff, mean_diff, Species)]"
  },
  {
    "objectID": "Week2/week2_part1.html#subset-of-the-original-data.table",
    "href": "Week2/week2_part1.html#subset-of-the-original-data.table",
    "title": "Table manipulation",
    "section": "Subset of the original Data.table",
    "text": "Subset of the original Data.table\n.SD (a smaller data.table that is a Subset of the original Data.table for each group)\n.SDcols (subset columns which are then used by .SD)\n\nSelect all columns with .SD. Select only a subset of all columns by .SDcols\n\n\n\n\n\n\n\n\n\n\nSelecting columns can be done by writing column names in .SDcols (Note: It is important to write it as stings in c() )\n\niris_dt[, .SD, .SDcols=c(\"Sepal.Width\", \"Species\")][1:2]\n\n\n\n  \n\n\n\nThis allows powerful calculation on subset of desired columns and groups.\n\n\n\n\n\n\n\n\n\nYou can use lapply() together with .SD (Subset of Data) to apply functions to selected columns within groups. This is particularly useful for performing calculations like mean or sum on a subset of numeric columns.\n\niris_dt[, lapply(.SD, mean), by=Species, .SDcols=1:2]\n\n\n\n  \n\n\n\nApply mean to all numeric columns by species\n\niris_dt[, lapply(.SD, mean), by=Species, .SDcols=is.numeric]\n\n\n\n  \n\n\n\n.SD is amazing for selecting first and last row of certain group since we can imagine every group with selected table as a new separate data table. As well as other operation that can be done on data.table.\n\n\n\n\n\n\n\n\n\n\niris_dt[, .SD[c(1, .N)], by=Species]\n\n\n\n  \n\n\n\n\nTask: .SD\nOrder the results by Petal.Width and select first three (smallest) observations by species. Calculate mean of first three columns for iris_dt for those observations. Do it in one command with chaining.\n\n# Write the solution here\n\n\n\nRegular expression trick within data.table .SD\nThe combination of .SD and regular expressions provides a powerful way to work with multiple columns in data.table. Instead of typing every column name, you can use regex to select, transform, or summarize groups of variables in one step using data.table::patterns.\n\n\n\n\n\n\nNote\n\n\n\nKey points:\n- .SD contains only the columns specified in .SDcols.\n- .SDcols = patterns(\"regex1\", \"regex2\") selects columns matching all the given regex patterns.\n- Useful for grouped operations, bulk transformations, or creating multiple new columns at once.\n\n\n\nA short peek: what are regex?\n\n\n\n\n\n\nTip\n\n\n\nRegular expressions (regex) are just search patterns for text.\n- \"Sepal\" → matches any column with \"Sepal\" in the name\n- \"^Sepal\" → matches columns starting with \"Sepal\"\n- \"Length$\" → matches columns ending with \"Length\"\n- \"(Sepal|Petal)\" → matches either \"Sepal\" or \"Petal\"\n\n\nWe’ll cover regex more deeply later — for now, just think of them as “smart wildcards” for column names.\n\n\nExample\n\niris_dt[, lapply(.SD, mean), .SDcols = patterns(\"Sepal\")]"
  },
  {
    "objectID": "Week2/week2_part1.html#combining-tables",
    "href": "Week2/week2_part1.html#combining-tables",
    "title": "Table manipulation",
    "section": "Combining tables",
    "text": "Combining tables\n\nBinding tables\nHow to “stitch” two or more data objects into one?\n\ntb1 <- data.table(sampleID = c(6:1),\n                  cancer = c(\"Breast\",\"Breast\",\"Brain\",\"Liver\",\"Brain\",\"Pancreas\"))\ntb2 <- data.table(sampleID = c(7, 4, 6, 2, 8), \n                  gender = c(\"F\",\"F\",\"M\",\"F\",\"M\")) \nhead(tb1,3)\n\n\n\n  \n\n\nhead(tb2,3)\n\n\n\n  \n\n\n\nFunction rbind() binds the tables by rows. Try run the code below and see what happens. Why is that?\n\nrbind(tb1, tb2)\n\nError in rbindlist(l, use.names, fill, idcol, ignore.attr): Column 2 ['gender'] of item 2 is missing in item 1. Use fill=TRUE to fill with NA (NULL for list columns), or use.names=FALSE to ignore column names.\n\n\n\nrbind(tb1, tb2, fill=TRUE)\n\n\n\n  \n\n\n\nFunction cbind() binds the tables. Do you notice anything strange when you run the code below?\n\ncbind(tb1, tb2)\n\n\n\n  \n\n\n\n\n\nmerge()\n\n\n\n\n\nSpecify by which column you want to merge by and set the argument all= to TRUE to perform the full join\n\nmerge(tb1, tb2, by=\"sampleID\") #if setkey was used prior then merge(tb1,tb2) works the same\n\n\n\n  \n\n\nmerge(tb1, tb2, by=\"sampleID\", all=TRUE)\n\n\n\n  \n\n\n\nRight and left join\n\nmerge(tb1, tb2, by=\"sampleID\", all.x = TRUE)\n\n\n\n  \n\n\nmerge(tb1, tb2, by=\"sampleID\", all.y = TRUE)"
  },
  {
    "objectID": "Week2/week2_part1.html#tidying-the-table",
    "href": "Week2/week2_part1.html#tidying-the-table",
    "title": "Table manipulation",
    "section": "Tidying the table",
    "text": "Tidying the table\nTidying a data table often includes renaming columns to make them more informative or consistent.\n\n\n\n\n\n\nTip\n\n\n\nYou can rename columns using names() or colnames().\nnames(dt_cancer) <- vec_names\n\n\n\ndt_cancer <- merge(tb1, tb2, by=\"sampleID\", all=TRUE)\ndt_cancer\n\n\n\n  \n\n\nnames(dt_cancer)[1] <- \"id\"\ndt_cancer\n\n\n\n  \n\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can rename columns using data.table: setnames\nsetnames(dt_cancer, \"old_names\", \"new_names\")\n\n\n\nnames(dt_cancer)\n\n[1] \"id\"     \"cancer\" \"gender\"\n\nsetnames(dt_cancer,  \"id\", \"sampleID\")\nnames(dt_cancer)\n\n[1] \"sampleID\" \"cancer\"   \"gender\"  \n\n\n\nOrdering columns\nSubseting\ndt[,.(col3, col10, col2)]\n\ndt_cancer[,.(gender, sampleID)]\n\n\n\n  \n\n\n\ndata.table: setcolorder()\nsetcolorder(dt_cancer, neworder)\n\ndt_cancer\n\n\n\n  \n\n\nsetcolorder(dt_cancer, c(\"gender\",\"sampleID\"))\ndt_cancer"
  },
  {
    "objectID": "Week2/week2_part1.html#reshaping-the-table",
    "href": "Week2/week2_part1.html#reshaping-the-table",
    "title": "Table manipulation",
    "section": "Reshaping the table",
    "text": "Reshaping the table\nYou can create a modified version of an existing data.table by using copy() to avoid changing the original data. Then, use := to add or modify columns by reference.\nIn the example below, we create two new columns (BRCA2 and ATM) filled with random values between 40 and 6000 for 6 rows:\n\ntb.shape <- copy(tb1)\ntb.shape[, \":=\" (\n            BRCA2=sample(40:6000,6),\n            ATM=sample(40:6000,6)) ]\n\ntb.shape\n\n\n\n  \n\n\n\nmelt (wide to long)\nConvert DT to long form where money is a separate observation. measure.vars specify the set of columns we would like to collapse (or combine) together.\n\nmelt(tb.shape, id.vars = c(\"sampleID\", \"cancer\"),\n                measure.vars = c(\"BRCA2\", \"ATM\"))\n\n\n\n  \n\n\n\nWe can also specify column indices instead of names.\n\n(tb1.m1  <- melt(tb.shape, \n                 measure.vars = c(\"BRCA2\", \"ATM\"),\n                 variable.name = \"genes\",\n                 value.name = \"n_mutations\")  \n )\n\n\n\n  \n\n\n\ndcast (long to wide)\nWe want to get the original table from the previous reshaped one using dcast()\n\ndcast(tb1.m1, sampleID + cancer ~ genes, value.var = \"n_mutations\")"
  },
  {
    "objectID": "Week2/week2_part1.html#saving-a-table-with-fwrite",
    "href": "Week2/week2_part1.html#saving-a-table-with-fwrite",
    "title": "Table manipulation",
    "section": "Saving a table with fwrite()",
    "text": "Saving a table with fwrite()\nThe fwrite() function from the data.table package is a fast and efficient way to write data tables to disk.\n\n\n\n\n\n\nTip\n\n\n\nfwrite(dt, file = “results/iris_summary.csv”)"
  },
  {
    "objectID": "Week2/week2_part3.html",
    "href": "Week2/week2_part3.html",
    "title": "Tidy table",
    "section": "",
    "text": "Important\n\n\n\nAn absolute path always contains the root element and the complete directory list required to locate the file.\n\nD:/User/MyFolder/Algorithms_and_programming/Homework/\n\nA relative path needs to be combined with another path in order to access a file.\n\n../Algorithms_and_programming/Homework/\n\n\n\nWe save the path to a CSV file from the web into a variable called `my_file`. This file will be used for demonstrations throughout the lecture.\n\nmy_file <- \"https://raw.githubusercontent.com/bot13956/datasets/master/introduction_to_physics_grades.csv\"\n\n\n\n\nTab Separated Values (TSV)and Comma Separated Values (CSV). A .tsv file will have tab separated values whereas .csv file has comma separated fields.\n\n\n\n\n\n\n\nNote\n\n\n\nEach function for corectly importing tables contains important arguments such as,\n\nheader - If TRUE then any empty column names are given a name where first data line is a character (non-empty)\nsep - The separator between columns. Most commonly used are “;”, “,”;“..\nskip - number of rows to remove starting from 0 (default) on the first line\nfill - If TRUE then in case the rows have unequal length, blank fields are implicitly added\ndec - the character used in the file for decimal points\ncol_names - assign new column names (string)\n\nand many others depending on the used function.\n\n\n\n\nReads a file in table format and creates a data frame from it, with cases corresponding to lines and variables to fields in the file.\n\nread.csv( my_file )\n\n\n\n  \n\n\n\n\n\n\nReads a file in table format and creates a data frame from it, with cases corresponding to lines and variables to fields in the file.\n\nread.table( my_file )\n\n\n\n  \n\n\n\n\n\n\nSimilar to read.table but faster and more convenient. All controls such as sep, colClasses and nrows are automatically detected.\n\nfread( my_file )"
  },
  {
    "objectID": "Week2/week2_part3.html#read-non-tabular-data",
    "href": "Week2/week2_part3.html#read-non-tabular-data",
    "title": "Tidy table",
    "section": "Read non-tabular data",
    "text": "Read non-tabular data\nImport data one line at the time\n\nreadLines\n\n# Apply readLines function to txt file\nreadLines(my_file) %>% \n  head()\n\n[1] \"Count,Score,Grade\" \"1,75.0,C\"          \"2,5.0,F\"          \n[4] \"3,20.0,F\"          \"4,87.5,B\"          \"5,100.0,A\"        \n\n\n\n\nread_lines from package readr\n\nreadr::read_lines(my_file) %>% \n  head()\n\n[1] \"Count,Score,Grade\" \"1,75.0,C\"          \"2,5.0,F\"          \n[4] \"3,20.0,F\"          \"4,87.5,B\"          \"5,100.0,A\"        \n\n\n\n\nReading tabular data as a list or a vector\nscan() function can also work when handling data that is stored in simple delimited text files. Unlike the read.table() function, the scan() function returns a list or a vector, not a dataframe.\n\nwhat the type of what gives the type of data to be read. (Here ‘type’ is used in the sense of typeof.) The supported types are logical, integer, numeric, complex, character, raw and list\n\n\nscan(my_file, sep=\",\", what = \"character\") %>% head\n\n[1] \"Count\" \"Score\" \"Grade\" \"1\"     \"75.0\"  \"C\"    \n\nscan(my_file,sep=\",\",  what=list(\"\", \"\", \"\"), skip = 1) %>% \n  lapply(., function(x) x[1:8])\n\n[[1]]\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\"\n\n[[2]]\n[1] \"75.0\"  \"5.0\"   \"20.0\"  \"87.5\"  \"100.0\" \"97.5\"  \"95.0\"  \"30.0\" \n\n[[3]]\n[1] \"C\" \"F\" \"F\" \"B\" \"A\" \"A\" \"A\" \"F\""
  },
  {
    "objectID": "Week2/week2_part3.html#saving-data",
    "href": "Week2/week2_part3.html#saving-data",
    "title": "Tidy table",
    "section": "Saving data",
    "text": "Saving data\n\n\n\n\n\n\nNote\n\n\n\nImportant argumnts, my vary depending on the used function\n\nsep - The separator between columns (“,”, “;”)\nappend - If TRUE, the file is opened in append mode and column names (header row) are not written. If FALSE, it will overwrite the existing file\nquote - factor fields and column names will only be surrounded by double quotes\ncol.names or row.names - T or F\n\nExamples of how to save data\n\nwrite.table(dt,\"PATH/TO/FILE.csv\", row.names = FALSE)\nwrite.csv(dt,\"PATH/TO/FILE.csv\", row.names = FALSE)\nfwrite(dt, \"PATH/TO/FILE.csv\") \n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe fwrite() function from the data.table package is a fast and efficient way to write data tables to disk.\n\n\n\nR data format\n\nSaving a single R object\nYou can save one R object (e.g., a data frame, vector, or model) to a file in RDS format using saveRDS().\n\nsaveRDS(object, file): writes the object to disk.\n\nreadRDS(file): loads the object back into R.\n\nYou can assign the loaded object to any name you like (the original object name is not preserved).\n\n\n# Save a single object to a file\nsaveRDS(my_table, \"my_data.rds\")\n\n# Restore it under a different name\nmy_old_table <- readRDS(\"my_data.rds\")\n\n\n\nSaving multiple R objects (.RData / .rda)\nThe save() function can store one or more R objects together in a single file.\nThese files are usually saved with the extension .RData or .rda.\n\nsave(object1, object2, ..., file = \"name.RData\") → saves the specified objects.\n\nload(\"name.RData\") → restores all saved objects into the current workspace with their original names.\n\n\n# Save multiple objects\nsave(my_table1, my_table2, file = \"data.RData\")\n# To load the data again\nload(\"data.RData\")\n\n\n\nSaving your entire workspace in a specified file\nIf you want to save everything currently in your R session (all variables, data frames, models, functions, etc.), you can use save.image().\nThis is essentially a shortcut for saving the entire global environment into a single file, usually with the extension .RData.\n\nsave.image(file = \"my_workspace.RData\") → saves the entire workspace.\n\nload(\"my_workspace.RData\") → restores the full workspace later.\n\n\n# Save everything from the current R session\nsave.image(file = \"my_work_space.RData\")\n# load back the workspace\nload(\"my_work_space.RData\")\n\n\n\n\n\n\n\nTip\n\n\n\nWhile save.image() is convenient, it’s not always the best choice:\n\nIt can save unnecessary objects, making files very large.\n\nIt may hide dependencies (you won’t remember later which objects were actually needed).\n\nFor reproducibility, it’s usually better to save only the objects you need with save() or saveRDS() and rebuild the rest from your script.\n\nRule of thumb:\nUse save.image() for quick backups or temporary sessions, but prefer save() / saveRDS() for clean, shareable projects."
  },
  {
    "objectID": "Week2/week2_part3.html#excel",
    "href": "Week2/week2_part3.html#excel",
    "title": "Tidy table",
    "section": "Excel",
    "text": "Excel\n\nPackage: **readxl**\nThe readxl package is the most common way to import Excel files in R.\nIt has no external dependencies (unlike older packages such as xlsx or XLConnect) and works on all platforms.\n\nSupports both .xls (Excel 97–2003) and .xlsx (Excel 2007+) formats.\n\nReturns a tibble (a modern data frame).\n\nDoes not require Excel or Java to be installed on your computer.\n\nProvides fast, read-only access (you cannot write Excel files with readxl; for that, use openxlsx or writexl).\n\n\nDifference between read_excel, read_xls, and read_xlsx\nAll three functions come from the readxl package.\n\n\n\n\n\n\n\n\nFunction\nSupported format(s)\nNotes\n\n\n\n\nread_excel()\nBoth .xls and .xlsx\nGeneric function, automatically detects file type. Recommended in most cases.\n\n\nread_xls()\nOnly .xls\nWrapper specialized for old Excel files (97–2003).\n\n\nread_xlsx()\nOnly .xlsx\nWrapper specialized for modern Excel files (2007+).\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn most cases, just use read_excel() — it works for both formats and is the most flexible.\n\n\n\n\nExample of manipulation with Excel files\n\n# Read the first sheet by index\nread_excel(\"PATH/TO/EXCEL.xlsx\", sheet = 1)\n\n# Read a sheet by name (\"ATM\" in this case)\nread_excel(\"PATH/TO/EXCEL.xlsx\", sheet = \"ATM\")\n\n# Save the first table into a new Excel file, sheet named \"My_sheet\"\nwrite.xlsx(my_table,\n           file = \"PATH/TO/My_EXCEL.xlsx\",\n           sheetName = \"My_sheet\", \n           col.names = TRUE,\n           row.names = TRUE, \n           append = FALSE)\n\n# Save a second table into the same file, sheet named \"sheet2\"\nwrite.xlsx(my_table2,\n           file = \"PATH/TO/My_EXCEL.xlsx\",\n           sheetName = \"sheet2\",\n           append = TRUE,\n           row.names = FALSE)"
  },
  {
    "objectID": "Week2/week2_part3.html#multiple-files",
    "href": "Week2/week2_part3.html#multiple-files",
    "title": "Tidy table",
    "section": "Multiple files",
    "text": "Multiple files\n\n\n\n\n\n\nImportant\n\n\n\nHow to import multiple files at once?\nUsing list.files function which has the following important arguments:\n\npath - ptah to your folder containing multiple files and subfolders\npattern - regular expression\nfull.names - If TRUE, the directory path is prepended to the file names to give a relative file path.\n\n\n\n\nExample of importing multiple files\nWhat are the data structures of temp and myfiles variables?\n\ntemp <- list.files(path = \"test_data/\", \n                   pattern=\"*.csv\", \n                   full.names = TRUE)\nmyfiles <- lapply(temp, fread)\n\ntemp\n\n[1] \"test_data/breast.csv\"   \"test_data/colon.csv\"    \"test_data/lung.csv\"    \n[4] \"test_data/prostate.csv\"\n\nmyfiles %>% \n  .[1:2]\n\n[[1]]\n   sampleID number_of_mutations type_of_mutation cancer_type\n     <char>               <int>           <char>      <char>\n1:  BRE_001                  89              SNV      Breast\n2:  BRE_002                 165              SNV      Breast\n3:  BRE_003                 110              CNV      Breast\n4:  BRE_004                  20               SV      Breast\n5:  BRE_005                 410              SNV      Breast\n6:  BRE_006                 370              CNV      Breast\n7:  BRE_007                 367              SNV      Breast\n8:  BRE_008                 387              SNV      Breast\n\n[[2]]\n   sampleID number_of_mutations type_of_mutation cancer_type\n     <char>               <int>           <char>      <char>\n1:  COL_001                 418            Indel       Colon\n2:  COL_002                 348              CNV       Colon\n3:  COL_003                 360              CNV       Colon\n4:  COL_004                 259            Indel       Colon\n5:  COL_005                 314            Indel       Colon\n6:  COL_006                 481               SV       Colon\n7:  COL_007                 298               SV       Colon\n8:  COL_008                  24               SV       Colon\n\n\n\n\nList and tables\n\nbase R: do.call\ndo.call() is mostly used with rbind or cbind, but it can apply any function to a list of arguments.\ndo.call(\"any_function\", arguments_list)\ncall(\"any_function\", argument1, argument2)\n\ndo.call(\"sum\", list(1:10))\n\n[1] 55\n\ndo.call(rbind, myfiles)\n\n\n\n  \n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhat is the difference between do.call and lapply?\nlapply() applies a given function for each element in a list, so there will be several function calls.\ndo.call() applies a given function to the list as a whole, so there is only one function call.\n\ndo.call(\"sum\", list(a=1:10, b=2:12))\n\n[1] 132\n\nlapply(list(a=1:10, b=2:12), sum)\n\n$a\n[1] 55\n\n$b\n[1] 77\n\n\n\n\n\n\ndata.table: rbindlist\nSame as do.call(“rbind”, l) on data.frames, but much faster.\n\nrbindlist(myfiles)\n\n\n\n  \n\n\n\n\n\nConvert any list to table\n\nmy_tb <- fread(my_file)\nmy_tb[, new_col := .GRP,.(Count >=50)]\n\nsplit(my_tb, by=c(\"Grade\", \"new_col\")) %>% .[1:2]\n\n$C.1\n   Count Score  Grade new_col\n   <int> <num> <char>   <int>\n1:     1  75.0      C       1\n2:    13  75.0      C       1\n3:    16  70.0      C       1\n4:    29  70.0      C       1\n5:    47  77.5      C       1\n\n$F.1\n   Count Score  Grade new_col\n   <int> <num> <char>   <int>\n1:     2   5.0      F       1\n2:     3  20.0      F       1\n3:     8  30.0      F       1\n4:    10  37.5      F       1\n5:    12  57.5      F       1\n6:    15  30.0      F       1\n7:    40  50.0      F       1\n8:    43  57.5      F       1\n9:    44  52.5      F       1\n\nsplit(my_tb, list(my_tb$Grade, my_tb$new_col)) %>% .[1:2]\n\n$A.1\n    Count Score  Grade new_col\n    <int> <num> <char>   <int>\n 1:     5 100.0      A       1\n 2:     6  97.5      A       1\n 3:     7  95.0      A       1\n 4:    11 100.0      A       1\n 5:    14  97.5      A       1\n 6:    17 100.0      A       1\n 7:    18  90.0      A       1\n 8:    19  90.0      A       1\n 9:    20  90.0      A       1\n10:    21  97.5      A       1\n11:    22 100.0      A       1\n12:    23  97.5      A       1\n13:    24  90.0      A       1\n14:    28 100.0      A       1\n15:    31 100.0      A       1\n16:    34 100.0      A       1\n17:    45  92.5      A       1\n18:    48  96.3      A       1\n\n$B.1\n   Count Score  Grade new_col\n   <int> <num> <char>   <int>\n1:     4  87.5      B       1\n2:    27  80.0      B       1\n3:    30  85.0      B       1\n4:    38  80.0      B       1\n5:    39  85.0      B       1\n6:    41  80.0      B       1\n7:    46  80.0      B       1\n8:    49  80.0      B       1\n\nsplit(my_tb, list(my_tb$Grade)) %>% .[1:2]\n\n$A\n     Count Score  Grade new_col\n     <int> <num> <char>   <int>\n  1:     5 100.0      A       1\n  2:     6  97.5      A       1\n  3:     7  95.0      A       1\n  4:    11 100.0      A       1\n  5:    14  97.5      A       1\n ---                           \n204:   775  93.0      A       2\n205:   776  90.0      A       2\n206:   778  96.0      A       2\n207:   791  93.0      A       2\n208:   798  99.0      A       2\n\n$B\n     Count Score  Grade new_col\n     <int> <num> <char>   <int>\n  1:     4  87.5      B       1\n  2:    27  80.0      B       1\n  3:    30  85.0      B       1\n  4:    38  80.0      B       1\n  5:    39  85.0      B       1\n ---                           \n208:   790  86.0      B       2\n209:   792  86.0      B       2\n210:   793  81.0      B       2\n211:   794  85.0      B       2\n212:   796  89.0      B       2"
  },
  {
    "objectID": "Week2/week2_part3.html#combining-tables",
    "href": "Week2/week2_part3.html#combining-tables",
    "title": "Tidy table",
    "section": "Combining tables",
    "text": "Combining tables\n\nBinding tables\nHow to “stitch” two or more data objects into one?\n\ntb1 <- data.table(sampleID = c(6:1),\n                  cancer = c(\"Breast\",\"Breast\",\"Brain\",\"Liver\",\"Brain\",\"Pancreas\"))\ntb2 <- data.table(sampleID = c(7, 4, 6, 2, 8), \n                  gender = c(\"F\",\"F\",\"M\",\"F\",\"M\")) \nhead(tb1,3)\n\n\n\n  \n\n\nhead(tb2,3)\n\n\n\n  \n\n\n\nFunction rbind() binds the tables by rows. Try run the code below and see what happens. Why is that?\n\nrbind(tb1, tb2)\n\nError in rbindlist(l, use.names, fill, idcol, ignore.attr): Column 2 ['gender'] of item 2 is missing in item 1. Use fill=TRUE to fill with NA (NULL for list columns), or use.names=FALSE to ignore column names.\n\n\n\nrbind(tb1, tb2, fill=TRUE)\n\n\n\n  \n\n\n\nFunction cbind() binds the tables. Do you notice anything strange when you run the code below?\n\ncbind(tb1, tb2)\n\n\n\n  \n\n\n\n\n\nmerge()\n\n\n\n\n\nSpecify by which column you want to merge by and set the argument all= to TRUE to perform the full join\n\nmerge(tb1, tb2, by=\"sampleID\") #if setkey was used prior then merge(tb1,tb2) works the same\n\n\n\n  \n\n\nmerge(tb1, tb2, by=\"sampleID\", all=TRUE)\n\n\n\n  \n\n\n\nRight and left join\n\nmerge(tb1, tb2, by=\"sampleID\", all.x = TRUE)\n\n\n\n  \n\n\nmerge(tb1, tb2, by=\"sampleID\", all.y = TRUE)"
  },
  {
    "objectID": "Week2/week2_part3.html#tidying-the-table",
    "href": "Week2/week2_part3.html#tidying-the-table",
    "title": "Tidy table",
    "section": "Tidying the table",
    "text": "Tidying the table\nTidying a data table often includes renaming columns to make them more informative or consistent.\n\n\n\n\n\n\nTip\n\n\n\nYou can rename columns using names() or colnames().\nnames(dt_cancer) <- vec_names\n\n\n\ndt_cancer <- merge(tb1, tb2, by=\"sampleID\", all=TRUE)\ndt_cancer\n\n\n\n  \n\n\nnames(dt_cancer)[1] <- \"id\"\ndt_cancer\n\n\n\n  \n\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can rename columns using data.table: setnames\nsetnames(dt_cancer, \"old_names\", \"new_names\")\n\n\n\nnames(dt_cancer)\n\n[1] \"id\"     \"cancer\" \"gender\"\n\nsetnames(dt_cancer,  \"id\", \"sampleID\")\nnames(dt_cancer)\n\n[1] \"sampleID\" \"cancer\"   \"gender\"  \n\n\n\nOrdering columns\nSubseting\ndt[,.(col3, col10, col2)]\n\ndt_cancer[,.(gender, sampleID)]\n\n\n\n  \n\n\n\ndata.table: setcolorder()\nsetcolorder(dt_cancer, neworder)\n\ndt_cancer\n\n\n\n  \n\n\nsetcolorder(dt_cancer, c(\"gender\",\"sampleID\"))\ndt_cancer"
  },
  {
    "objectID": "Week2/week2_part3.html#reshaping-the-table",
    "href": "Week2/week2_part3.html#reshaping-the-table",
    "title": "Tidy table",
    "section": "Reshaping the table",
    "text": "Reshaping the table\nYou can create a modified version of an existing data.table by using copy() to avoid changing the original data. Then, use := to add or modify columns by reference.\nIn the example below, we create two new columns (BRCA2 and ATM) filled with random values between 40 and 6000 for 6 rows:\n\ntb.shape <- copy(tb1)\ntb.shape[, \":=\" (\n            BRCA2=sample(40:6000,6),\n            ATM=sample(40:6000,6)) ]\n\ntb.shape\n\n\n\n  \n\n\n\n\nmelt (wide to long)\nConvert DT to long form where money is a separate observation. measure.vars specify the set of columns we would like to collapse (or combine) together.\n\nmelt(tb.shape, id.vars = c(\"sampleID\", \"cancer\"),\n                measure.vars = c(\"BRCA2\", \"ATM\"))\n\n\n\n  \n\n\n\nWe can also specify column indices instead of names.\n\n(tb1.m1  <- melt(tb.shape, \n                 measure.vars = c(\"BRCA2\", \"ATM\"),\n                 variable.name = \"genes\",\n                 value.name = \"n_mutations\")  \n )\n\n\n\n  \n\n\n\n\n\ndcast (long to wide)\nWe want to get the original table from the previous reshaped one using dcast()\n\ndcast(tb1.m1, sampleID + cancer ~ genes, value.var = \"n_mutations\")"
  },
  {
    "objectID": "Week2/week2_part3.html#saving-a-table-with-fwrite",
    "href": "Week2/week2_part3.html#saving-a-table-with-fwrite",
    "title": "Tidy table",
    "section": "Saving a table with fwrite()",
    "text": "Saving a table with fwrite()\nThe fwrite() function from the data.table package is a fast and efficient way to write data tables to disk.\n\n\n\n\n\n\nTip\n\n\n\nfwrite(dt, file = “results/iris_summary.csv”)"
  },
  {
    "objectID": "Week2/week2_part1.html#exercise-data.table",
    "href": "Week2/week2_part1.html#exercise-data.table",
    "title": "Table manipulation",
    "section": "Exercise data.table",
    "text": "Exercise data.table\nWe are going to resolve some of the task from HW1 using data.table for CO2 data.set.\n\nConvert CO2 to data.table object in a variable co2_dt.\n\n\n# Write the solution here\n\n\nCalculate the mean uptake for nonchilled plants and chilled plants.\n\n\n# Write the solution here\n\n\nAdd a new column to the dataset, smalluptake which will have values of uptake divided by 3.\n\n\n# Write the solution here\n\n\nCount the number of plants that have the value of smalluptake 3.1 or 4.1\n\n\n# Write the solution here\n\n\nAdd a column diffFromMeanUptake that will represent all the difference between uptake and the mean uptake for nonchilled plants and chilled plants.\n\n\n# Write the solution here"
  },
  {
    "objectID": "Week2/week2_part2.html",
    "href": "Week2/week2_part2.html",
    "title": "Tidy table",
    "section": "",
    "text": "Important\n\n\n\nAn absolute path always contains the root element and the complete directory list required to locate the file.\n\nD:/User/MyFolder/Algorithms_and_programming/Homework/\n\nA relative path needs to be combined with another path in order to access a file.\n\n../Algorithms_and_programming/Homework/\n\n\n\nWe save the path to a CSV file from the web into a variable called `my_file`. This file will be used for demonstrations throughout the lecture.\n\nmy_file <- \"https://raw.githubusercontent.com/bot13956/datasets/master/introduction_to_physics_grades.csv\"\n\n\n\n\nTab Separated Values (TSV)and Comma Separated Values (CSV). A .tsv file will have tab separated values whereas .csv file has comma separated fields.\n\n\n\n\n\n\n\nNote\n\n\n\nEach function for correctly importing tables contains important arguments such as,\n\nheader - If TRUE then any empty column names are given a name where first data line is a character (non-empty)\nsep - The separator between columns. Most commonly used are “;”, “,”;“..\nskip - number of rows to remove starting from 0 (default) on the first line\nfill - If TRUE then in case the rows have unequal length, blank fields are implicitly added\ndec - the character used in the file for decimal points\ncol_names - assign new column names (string)\n\nand many others depending on the used function.\n\n\n\n\nReads a file in table format and creates a data frame from it, with cases corresponding to lines and variables to fields in the file.\n\nread.csv( my_file )\n\n\n\n  \n\n\n\n\n\n\nReads a file in table format and creates a data frame from it, with cases corresponding to lines and variables to fields in the file.\n\nread.table( my_file )\n\n\n\n  \n\n\n\n\n\n\nSimilar to read.table but faster and more convenient. All controls such as sep, colClasses and nrows are automatically detected.\n\nfread( my_file )"
  },
  {
    "objectID": "Week2/week2_part2.html#read-non-tabular-data",
    "href": "Week2/week2_part2.html#read-non-tabular-data",
    "title": "Tidy table",
    "section": "Read non-tabular data",
    "text": "Read non-tabular data\nImport data one line at the time\n\nreadLines\n\n# Apply readLines function to txt file\nreadLines(my_file) %>% \n  head()\n\n[1] \"Count,Score,Grade\" \"1,75.0,C\"          \"2,5.0,F\"          \n[4] \"3,20.0,F\"          \"4,87.5,B\"          \"5,100.0,A\"        \n\n\n\n\nread_lines from package readr\n\nreadr::read_lines(my_file) %>% \n  head()\n\n[1] \"Count,Score,Grade\" \"1,75.0,C\"          \"2,5.0,F\"          \n[4] \"3,20.0,F\"          \"4,87.5,B\"          \"5,100.0,A\"        \n\n\n\n\nReading tabular data as a list or a vector\nscan() function can also work when handling data that is stored in simple delimited text files. Unlike the read.table() function, the scan() function returns a list or a vector, not a dataframe.\n\nwhat the type of what gives the type of data to be read. (Here ‘type’ is used in the sense of typeof.) The supported types are logical, integer, numeric, complex, character, raw and list\n\n\nscan(my_file, sep=\",\", what = \"character\") %>% head\n\n[1] \"Count\" \"Score\" \"Grade\" \"1\"     \"75.0\"  \"C\"    \n\nscan(my_file,sep=\",\",  what=list(\"\", \"\", \"\"), skip = 1) %>% \n  lapply(., function(x) x[1:8])\n\n[[1]]\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\"\n\n[[2]]\n[1] \"75.0\"  \"5.0\"   \"20.0\"  \"87.5\"  \"100.0\" \"97.5\"  \"95.0\"  \"30.0\" \n\n[[3]]\n[1] \"C\" \"F\" \"F\" \"B\" \"A\" \"A\" \"A\" \"F\""
  },
  {
    "objectID": "Week2/week2_part2.html#saving-data",
    "href": "Week2/week2_part2.html#saving-data",
    "title": "Tidy table",
    "section": "Saving data",
    "text": "Saving data\n\n\n\n\n\n\nNote\n\n\n\nImportant argumnts, my vary depending on the used function\n\nsep - The separator between columns (“,”, “;”)\nappend - If TRUE, the file is opened in append mode and column names (header row) are not written. If FALSE, it will overwrite the existing file\nquote - factor fields and column names will only be surrounded by double quotes\ncol.names or row.names - T or F\n\nExamples of how to save data\n\nwrite.table(dt,\"PATH/TO/FILE.csv\", row.names = FALSE)\nwrite.csv(dt,\"PATH/TO/FILE.csv\", row.names = FALSE)\nfwrite(dt, \"PATH/TO/FILE.csv\") \n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe fwrite() function from the data.table package is a fast and efficient way to write data tables to disk.\n\n\n\nR data format\n\nSaving a single R object\nYou can save one R object (e.g., a data frame, vector, or model) to a file in RDS format using saveRDS().\n\nsaveRDS(object, file): writes the object to disk.\n\nreadRDS(file): loads the object back into R.\n\nYou can assign the loaded object to any name you like (the original object name is not preserved).\n\n\n# Save a single object to a file\nsaveRDS(my_table, \"my_data.rds\")\n\n# Restore it under a different name\nmy_old_table <- readRDS(\"my_data.rds\")\n\n\n\nSaving multiple R objects (.RData / .rda)\nThe save() function can store one or more R objects together in a single file.\nThese files are usually saved with the extension .RData or .rda.\n\nsave(object1, object2, ..., file = \"name.RData\") → saves the specified objects.\n\nload(\"name.RData\") → restores all saved objects into the current workspace with their original names.\n\n\n# Save multiple objects\nsave(my_table1, my_table2, file = \"data.RData\")\n# To load the data again\nload(\"data.RData\")\n\n\n\nSaving your entire workspace in a specified file\nIf you want to save everything currently in your R session (all variables, data frames, models, functions, etc.), you can use save.image().\nThis is essentially a shortcut for saving the entire global environment into a single file, usually with the extension .RData.\n\nsave.image(file = \"my_workspace.RData\") → saves the entire workspace.\n\nload(\"my_workspace.RData\") → restores the full workspace later.\n\n\n# Save everything from the current R session\nsave.image(file = \"my_work_space.RData\")\n# load back the workspace\nload(\"my_work_space.RData\")\n\n\n\n\n\n\n\nTip\n\n\n\nWhile save.image() is convenient, it’s not always the best choice:\n\nIt can save unnecessary objects, making files very large.\n\nIt may hide dependencies (you won’t remember later which objects were actually needed).\n\nFor reproducibility, it’s usually better to save only the objects you need with save() or saveRDS() and rebuild the rest from your script.\n\nRule of thumb:\nUse save.image() for quick backups or temporary sessions, but prefer save() / saveRDS() for clean, shareable projects."
  },
  {
    "objectID": "Week2/week2_part2.html#excel",
    "href": "Week2/week2_part2.html#excel",
    "title": "Tidy table",
    "section": "Excel",
    "text": "Excel\n\nPackage: **readxl**\nThe readxl package is the most common way to import Excel files in R.\nIt has no external dependencies (unlike older packages such as xlsx or XLConnect) and works on all platforms.\n\nSupports both .xls (Excel 97–2003) and .xlsx (Excel 2007+) formats.\n\nReturns a tibble .\n\nDoes not require Excel or Java to be installed on your computer.\n\nProvides fast, read-only access (you cannot write Excel files with readxl; for that, use openxlsx or writexl).\n\n\nDifference between read_excel, read_xls, and read_xlsx\nAll three functions come from the readxl package.\n\n\n\n\n\n\n\n\nFunction\nSupported format(s)\nNotes\n\n\n\n\nread_excel()\nBoth .xls and .xlsx\nGeneric function, automatically detects file type. Recommended in most cases.\n\n\nread_xls()\nOnly .xls\nWrapper specialized for old Excel files (97–2003).\n\n\nread_xlsx()\nOnly .xlsx\nWrapper specialized for modern Excel files (2007+).\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nIn most cases, just use read_excel() — it works for both formats and is the most flexible.\n\n\n\n\nExample of manipulation with Excel files\n\n# Read the first sheet by index\nread_excel(\"PATH/TO/EXCEL.xlsx\", sheet = 1)\n\n# Read a sheet by name (\"ATM\" in this case)\nread_excel(\"PATH/TO/EXCEL.xlsx\", sheet = \"ATM\")\n\n# Save the first table into a new Excel file, sheet named \"My_sheet\"\nwrite.xlsx(my_table,\n           file = \"PATH/TO/My_EXCEL.xlsx\",\n           sheetName = \"My_sheet\", \n           col.names = TRUE,\n           row.names = TRUE, \n           append = FALSE)\n\n# Save a second table into the same file, sheet named \"sheet2\"\nwrite.xlsx(my_table2,\n           file = \"PATH/TO/My_EXCEL.xlsx\",\n           sheetName = \"sheet2\",\n           append = TRUE,\n           row.names = FALSE)"
  },
  {
    "objectID": "Week2/week2_part2.html#multiple-files",
    "href": "Week2/week2_part2.html#multiple-files",
    "title": "Tidy table",
    "section": "Multiple files",
    "text": "Multiple files\n\n\n\n\n\n\nImportant\n\n\n\nHow to import multiple files at once?\nUsing list.files function which has the following important arguments:\n\npath - ptah to your folder containing multiple files and subfolders\npattern - regular expression\nfull.names - If TRUE, the directory path is prepended to the file names to give a relative file path.\n\n\n\n\nExample of importing multiple files\nWhat are the data structures of temp and myfiles variables?\n\ntemp <- list.files(path = \"test_data/\", \n                   pattern=\"*.csv\", \n                   full.names = TRUE)\nmyfiles <- lapply(temp, fread)\n\ntemp\n\n[1] \"test_data/breast.csv\"   \"test_data/colon.csv\"    \"test_data/lung.csv\"    \n[4] \"test_data/prostate.csv\"\n\nmyfiles %>% \n  .[1:2]\n\n[[1]]\n   sampleID number_of_mutations type_of_mutation cancer_type\n     <char>               <int>           <char>      <char>\n1:  BRE_001                  89              SNV      Breast\n2:  BRE_002                 165              SNV      Breast\n3:  BRE_003                 110              CNV      Breast\n4:  BRE_004                  20               SV      Breast\n5:  BRE_005                 410              SNV      Breast\n6:  BRE_006                 370              CNV      Breast\n7:  BRE_007                 367              SNV      Breast\n8:  BRE_008                 387              SNV      Breast\n\n[[2]]\n   sampleID number_of_mutations type_of_mutation cancer_type\n     <char>               <int>           <char>      <char>\n1:  COL_001                 418            Indel       Colon\n2:  COL_002                 348              CNV       Colon\n3:  COL_003                 360              CNV       Colon\n4:  COL_004                 259            Indel       Colon\n5:  COL_005                 314            Indel       Colon\n6:  COL_006                 481               SV       Colon\n7:  COL_007                 298               SV       Colon\n8:  COL_008                  24               SV       Colon\n\n\n\n\nList and tables\n\nbase R: do.call\ndo.call() is mostly used with rbind or cbind, but it can apply any function to a list of arguments.\ndo.call(\"any_function\", arguments_list)\ncall(\"any_function\", argument1, argument2)\n\ndo.call(\"sum\", list(1:10))\n\n[1] 55\n\ndo.call(rbind, myfiles)\n\n\n\n  \n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhat is the difference between do.call and lapply?\nlapply() applies a given function for each element in a list, so there will be several function calls.\ndo.call() applies a given function to the list as a whole, so there is only one function call.\n\ndo.call(\"sum\", list(a=1:10, b=2:12))\n\n[1] 132\n\nlapply(list(a=1:10, b=2:12), sum)\n\n$a\n[1] 55\n\n$b\n[1] 77\n\n\n\n\n\n\ndata.table: rbindlist\nSame as do.call(“rbind”, l) on data.frames, but much faster.\n\nrbindlist(myfiles)\n\n\n\n  \n\n\n\n\n\nConvert any list to table\n\nmy_tb <- fread(my_file)\nmy_tb[, new_col := .GRP,.(Count >=50)]\n\nsplit(my_tb, by=c(\"Grade\", \"new_col\")) %>% .[1:2]\n\n$C.1\n   Count Score  Grade new_col\n   <int> <num> <char>   <int>\n1:     1  75.0      C       1\n2:    13  75.0      C       1\n3:    16  70.0      C       1\n4:    29  70.0      C       1\n5:    47  77.5      C       1\n\n$F.1\n   Count Score  Grade new_col\n   <int> <num> <char>   <int>\n1:     2   5.0      F       1\n2:     3  20.0      F       1\n3:     8  30.0      F       1\n4:    10  37.5      F       1\n5:    12  57.5      F       1\n6:    15  30.0      F       1\n7:    40  50.0      F       1\n8:    43  57.5      F       1\n9:    44  52.5      F       1\n\nsplit(my_tb, list(my_tb$Grade, my_tb$new_col)) %>% .[1:2]\n\n$A.1\n    Count Score  Grade new_col\n    <int> <num> <char>   <int>\n 1:     5 100.0      A       1\n 2:     6  97.5      A       1\n 3:     7  95.0      A       1\n 4:    11 100.0      A       1\n 5:    14  97.5      A       1\n 6:    17 100.0      A       1\n 7:    18  90.0      A       1\n 8:    19  90.0      A       1\n 9:    20  90.0      A       1\n10:    21  97.5      A       1\n11:    22 100.0      A       1\n12:    23  97.5      A       1\n13:    24  90.0      A       1\n14:    28 100.0      A       1\n15:    31 100.0      A       1\n16:    34 100.0      A       1\n17:    45  92.5      A       1\n18:    48  96.3      A       1\n\n$B.1\n   Count Score  Grade new_col\n   <int> <num> <char>   <int>\n1:     4  87.5      B       1\n2:    27  80.0      B       1\n3:    30  85.0      B       1\n4:    38  80.0      B       1\n5:    39  85.0      B       1\n6:    41  80.0      B       1\n7:    46  80.0      B       1\n8:    49  80.0      B       1\n\nsplit(my_tb, list(my_tb$Grade)) %>% .[1:2]\n\n$A\n     Count Score  Grade new_col\n     <int> <num> <char>   <int>\n  1:     5 100.0      A       1\n  2:     6  97.5      A       1\n  3:     7  95.0      A       1\n  4:    11 100.0      A       1\n  5:    14  97.5      A       1\n ---                           \n204:   775  93.0      A       2\n205:   776  90.0      A       2\n206:   778  96.0      A       2\n207:   791  93.0      A       2\n208:   798  99.0      A       2\n\n$B\n     Count Score  Grade new_col\n     <int> <num> <char>   <int>\n  1:     4  87.5      B       1\n  2:    27  80.0      B       1\n  3:    30  85.0      B       1\n  4:    38  80.0      B       1\n  5:    39  85.0      B       1\n ---                           \n208:   790  86.0      B       2\n209:   792  86.0      B       2\n210:   793  81.0      B       2\n211:   794  85.0      B       2\n212:   796  89.0      B       2"
  },
  {
    "objectID": "Week2/week2_part2.html#combining-tables",
    "href": "Week2/week2_part2.html#combining-tables",
    "title": "Tidy table",
    "section": "Combining tables",
    "text": "Combining tables\n\nBinding tables\nHow to “stitch” two or more data objects into one?\n\ntb1 <- data.table(sampleID = c(6:1),\n                  cancer = c(\"Breast\",\"Breast\",\"Brain\",\"Liver\",\"Brain\",\"Pancreas\"))\ntb2 <- data.table(sampleID = c(7, 4, 6, 2, 8), \n                  gender = c(\"F\",\"F\",\"M\",\"F\",\"M\")) \nhead(tb1,3)\n\n\n\n  \n\n\nhead(tb2,3)\n\n\n\n  \n\n\n\nFunction rbind() binds the tables by rows. Try run the code below and see what happens. Why is that?\n\nrbind(tb1, tb2)\n\nError in rbindlist(l, use.names, fill, idcol, ignore.attr): Column 2 ['gender'] of item 2 is missing in item 1. Use fill=TRUE to fill with NA (NULL for list columns), or use.names=FALSE to ignore column names.\n\n\n\nrbind(tb1, tb2, fill=TRUE)\n\n\n\n  \n\n\n\nFunction cbind() binds the tables. Do you notice anything strange when you run the code below?\n\ncbind(tb1, tb2)\n\n\n\n  \n\n\n\n\n\nmerge()\n\n\n\n\n\nSpecify by which column you want to merge by and set the argument all= to TRUE to perform the full join\n\nmerge(tb1, tb2, by=\"sampleID\") #if setkey was used prior then merge(tb1,tb2) works the same\n\n\n\n  \n\n\nmerge(tb1, tb2, by=\"sampleID\", all=TRUE)\n\n\n\n  \n\n\n\nRight and left join\n\nmerge(tb1, tb2, by=\"sampleID\", all.x = TRUE)\n\n\n\n  \n\n\nmerge(tb1, tb2, by=\"sampleID\", all.y = TRUE)\n\n\n\n  \n\n\n\n\n\nKEYS\nUse setkey() on data table. This will result in ordered table by the key(s) (columns you have specified) that allows for faster manipulation of data (especially like in merge function!!!)\nSetting a key does two things:\n\nphysically reorders the rows of the data.table by the column(s) provided by reference, always in increasing order.\nmarks those columns as key columns by setting an attribute called sorted to the data.table.\n\nSince the rows are reordered, a data.table can have at most one key because it can not be sorted in more than one way.\nWhat happened in the code chunk below?\n\nsetkey(tb1, sampleID)\nsetkey(tb2, sampleID)\nhead(tb1, 3)\n\n\n\n  \n\n\nhead(tb2,3)\n\n\n\n  \n\n\n\n\ndata.table: [] instead of merge()\nWhat happened here?\n\nsetkey(tb1, sampleID)\nsetkey(tb2, sampleID)\ntb1[tb2]\n\n\n\n  \n\n\ntb2[tb1]\n\n\n\n  \n\n\n\n\n\n\nSummary"
  },
  {
    "objectID": "Week2/week2_part2.html#tidying-the-table",
    "href": "Week2/week2_part2.html#tidying-the-table",
    "title": "Tidy table",
    "section": "Tidying the table",
    "text": "Tidying the table\nTidying a data table often includes renaming columns to make them more informative or consistent.\n\n\n\n\n\n\nTip\n\n\n\nYou can rename columns using names() or colnames().\nnames(dt_cancer) <- vec_names\n\n\n\ndt_cancer <- merge(tb1, tb2, by=\"sampleID\", all=TRUE)\ndt_cancer\n\n\n\n  \n\n\nnames(dt_cancer)[1] <- \"id\"\ndt_cancer\n\n\n\n  \n\n\n\n\n\n\n\n\n\nTip\n\n\n\nYou can rename columns using data.table: setnames\nsetnames(dt_cancer, \"old_names\", \"new_names\")\n\n\n\nnames(dt_cancer)\n\n[1] \"id\"     \"cancer\" \"gender\"\n\nsetnames(dt_cancer,  \"id\", \"sampleID\")\nnames(dt_cancer)\n\n[1] \"sampleID\" \"cancer\"   \"gender\"  \n\n\n\nOrdering columns\nSubseting\ndt[,.(col3, col10, col2)]\n\ndt_cancer[,.(gender, sampleID)]\n\n\n\n  \n\n\n\ndata.table: setcolorder()\nsetcolorder(dt_cancer, neworder)\n\ndt_cancer\n\n\n\n  \n\n\nsetcolorder(dt_cancer, c(\"gender\",\"sampleID\"))\ndt_cancer"
  },
  {
    "objectID": "Week2/week2_part2.html#reshaping-the-table",
    "href": "Week2/week2_part2.html#reshaping-the-table",
    "title": "Tidy table",
    "section": "Reshaping the table",
    "text": "Reshaping the table\nYou can create a modified version of an existing data.table by using copy() to avoid changing the original data. Then, use := to add or modify columns by reference.\nIn the example below, we create two new columns (BRCA2 and ATM) filled with random values between 40 and 6000 for 6 rows:\n\ntb.shape <- copy(tb1)\ntb.shape[, \":=\" (\n            BRCA2=sample(40:6000,6),\n            ATM=sample(40:6000,6)) ]\n\ntb.shape\n\n\n\n  \n\n\n\n\nmelt (wide to long)\nConvert DT to long form where money is a separate observation. measure.vars specify the set of columns we would like to collapse (or combine) together.\n\nmelt(tb.shape, id.vars = c(\"sampleID\", \"cancer\"),\n                measure.vars = c(\"BRCA2\", \"ATM\"))\n\n\n\n  \n\n\n\nWe can also specify column indices instead of names.\n\n(tb1.m1  <- melt(tb.shape, \n                 measure.vars = c(\"BRCA2\", \"ATM\"),\n                 variable.name = \"genes\",\n                 value.name = \"n_mutations\")  \n )\n\n\n\n  \n\n\n\n\n\ndcast (long to wide)\nWe want to get the original table from the previous reshaped one using dcast()\n\ndcast(tb1.m1, sampleID + cancer ~ genes, value.var = \"n_mutations\")\n\n\n\n  \n\n\n\n\n\nExercise\nWe are going to do an analysis of mtcars dataset using data.table.\n\nhead(mtcars)\n\n\n\n  \n\n\n\nDo the following:\nConvert mtcars to data.table called mtcars_dt. Add rownames from data.frame to your data.table under the column carnames\n\n\n\nOn the following datasets (dt1 and dt2) perform inner join, left join and outer joins. Do it with merge(), and where you can with []\n\ndt1 <- mtcars_dt[5:25,.(carnames, mpg, cyl)]\ndt2 <- mtcars_dt[1:10, .(carnames, gear)]\n## Using merge() -----------------\n# Inner Join\n\n# Left Join\n\n# Outer Join\n\n\n## Withouth merge() --------------------\n\n# Left Join\n\nCreate a wider table showing the mpg values for cyl vs carnames (Carb)"
  }
]