{"title":"Week 1 - Lecture 1","markdown":{"yaml":{"title":"Week 1 - Lecture 1","format":{"html":{"self-contained":true,"toc":true,"toc-depth":5,"code-fold":false,"fig-align":"center","df-print":"paged","code-summary":"Show code","code-line-numbers":false,"code-tools":true}}},"headingText":"Welcome to Algorithms & Programming!","containsRefs":false,"markdown":"\n\n\n-   homeworks + exam\n-   Moodle forum\n-   no copy-pasting, no group work\n-   NO ChatGPT!!\n-   student participation !!!\n\n## R\n\n-   toolbox for statistical analyses and data manipulation\n-   advanced, flexible data formats\n-   user-friendly\n-   simple syntax\n-   packages\n-   community: documentation, stackOverflow, Github, Biostars...\n\n### Google. Google. Google.\n\n## Make your R usage easier\n\n### Tips&Tricks\n\n-   Ctrl+Enter to run code/send to console\n-   tab for auto-complete\n-   keyboard shortcuts listed in *Help*\n-   History: send to console, up arrow\n-   Help: search manually or from console (?, ??, example())\n-   adjust defaults in Global options\n\n## Make your R usage easier\n\n### Rmarkdown (<https://rmarkdown.rstudio.com/>)\n\n-   various outputs for sharing your work (.html, .pdf, Word, website...)\n-   text + code chunks\n-   `Ctrl+Alt+I` to insert new chunk\n-   chunk options (message, warning, fig...)\n\n## Make your R usage easier\n\n### User interfaces\n\n1.  RGui - useful when upgrading versions (package *installR*)\n2.  RStudio - additional functionality, projects\n\n## Basic components\n\n-   variables\\\n-   functions\\\n-   environment\n\nFor starters, you can use R as a calculator:\n\n```{r, results = \"hold\"}\n3 + 5\n10/2\n4^2\n8 %/% 3\n8 %% 3\n```\n\nSome basic functions:\n\n```{r, results = \"hold\"}\nround(1.86)\nsqrt(25)\nlog10(1000)\n```\n\n## Variables\n\n-   everything is a vector\\\n-   assignment:\n    -   **`<-`**\n    -   `<<-`\\\n    -   `=`\n    -   but don't touch the last two!!!\n    -   `n <- 5`\n-   create/collate: `c()`\\\n-   view: `print()` or type name\n\n## Vectors\n\n-   character, numeric (integer and double), logical\n-   `class(), typeof()`\n-   `as.x()` family of functions\n\nCreate your first variable:\n\n```{r}\nn <- 9\n```\n\nLet's see it:\n\n```{r, results = \"hold\"}\nn\nprint(n)\nclass(n)\n```\n\nAs we said, every variable in R is a vector. So what does this mean?\n\nLet's add one more number to our variable n using function c():\n\n```{r, results = \"hold\"}\nn <- c(n, 16); n\nclass(n)\n```\n\nHow do functions work on this?\n\n```{r}\nsqrt(n)\n```\n\nWhat happens when we try to add a letter?\n\n```{r, results = \"hold\"}\nn <- c(n, \"z\"); n\nclass(n)\n```\n\n**Numeric vector:**\n\n```{r, results = \"hold\"}\nn1 <- c(1,2,4); n1\nas.character(n1)\n```\n\nCreate sequential numeric vector:\n\n```{r}\nn2 <- 1:10; n2\n```\n\n**Character vector:**\n\n```{r, results = \"hold\"}\nch <- c(\"a\", \"b\", \"c\", \"d\", \"spanishinquisition\"); ch\n```\n\n## Boolean variable\n\n**TRUE FALSE**\n\nIt is a binary variable.\n\n```{r}\nbool <- c(T,F,T,T,F); bool\nas.numeric(bool)\nbin <- c(0,1,1,0,1); bin\nclass(bin)\nas.logical(bin)\n```\n\n## Boolean operators\n\n-   **AND** `&`\n-   **OR** `|`\n-   **NOT** `!`\n\n```{r}\nprint(bool)\nprint(bin)\n```\n\n1.  **&** and **\\|** are vectorised\n\n2.  **&&** and **\\|\\|** are short-circuited\n\n```{r, eval=FALSE}\nbool & bin\nbool && bin\n```\n\n```{r, eval=FALSE}\nbool | bin\nbool || bin\n```\n\n```{r, eval=FALSE}\n!bool\n!bool || bin\n```\n\n### Comparison operators\n\n**==**\n\n**!=**\n\n**\\>**\n\n**\\>=**\n\n**\\<**\n\n**\\<=**\n\n```{r}\nn2\nn2 == 2\nn2 > 5\nn2 >= 5\n```\n\n### Comparison operators\n\n```{r, results = \"hold\"}\nbool\nbin\n```\n\n```{r}\nbool == bin\nbool != bin\n```\n\n### RECYCLING\n\nWhat happens when vectors are not the same length?\n\n```{r}\nn1; n2\nn2*c(2,3)\n```\n\n```{r, results = \"hold\"}\nn2*n1\nn2 == n1\n```\n\n## Basic functions\n\n`length()` : how many elements in a vector\n\n```{r, results = \"hold\"}\nmyvec <- 1:20\nlength(myvec)\n```\n\n```{r, results = \"hold\"}\nlength(\"banana\")\nnchar(\"banana\")\n```\n\n`which()` : returns positions of elements which satisfy the condition\n\n```{r, results = \"hold\"}\nwhich(n1 == 4)\nwhich((myvec<=2) | (myvec>17))\n```\n\n## Basic functions\n\n`names()` : gives names to the elements\n\n```{r, results = \"hold\"}\nnames(ch) <- c(\"letter\", \"letter\", \"letter\", \"anotherletter\", \"nobodyexpected\")\nch\n```\n\n`%in%` operator - are elements of the first vector present in the second vector?\n\n```{r}\nn2 %in% n1 \n```\n\n## Basic functions\n\n`unique()` : returns unique elements\n\n```{r, results = \"hold\"}\nn3 <- c(0,0,0,0,1,1,1,2,2,2,2,2,3,3,3,3,5)\nunique(n3)\n```\n\n`duplicated()` : logical: did the same element appear before in the vector?\n\n```{r, results = \"hold\"}\nduplicated(n3)\nduplicated(c(5, n3))\n```\n\n`table()` : how many times does each unique element appear\n\n```{r}\ntable(n3)\n```\n\nGet just the frequencies from table:\n\n```{r, results = \"hold\"}\nn3\nas.numeric(table(n3))\n```\n\nGet unique elements using names - but be careful!\n\n```{r, results = \"hold\"}\nnames(table(n3))\nclass(names(table(n3)))\n```\n\n### Taking a sample\n\n`sample()` : take a sample from vector\n\n```{r, results = \"hold\"}\nsample(n3, 4)\nsample(n3, 25, replace=TRUE)\n```\n\nTake a sample from some basic distributions:\n![](normal_distribution.jpg)\n\n```{r, results = \"hold\"}\nsample(1:100, size = 10)\nrunif(10, min=1, max=100)\ns <- rnorm(20, mean=3, sd=0.7); s\n```\n\n### Generating sequences\n\n`seq()`\n\n```{r, results = \"hold\"}\nseq(from=1, to=100, by=2)\nseq(from=0, to=10, length.out=21)\n```\n\n`rep()`\n\n```{r, results = \"hold\"}\nrep(1:3, times=4)\nrep(1:3, each=4)\n```\n\ndon't mix up `rep()` and `replicate()`!\n\n```{r}\nreplicate(n = 10, expr = mean(sample(x = 1:10, size = 3)) )\n```\n\n### Basic statistics\n\n```{r}\nmean(s)\nsd(s)\nquantile(s)\n```\n\n## Vector subsetting \\[\\]\n\n1.  **by position**\n2.  by condition\n\nOne position:\n\n```{r}\nn1[3] \n```\n\nMultiple positions:\n\n```{r, results = \"hold\"}\nn2[1:5]\nch[c(2,4,5)]\n```\n\nEverything except 1 position:\n\n```{r}\nn2[-7]\n```\n\nPositions stored in another vector:\n\n```{r}\nn2[n1]\n```\n\n## Vector subsetting \\[\\]\n\n1.  by position\n2.  **by condition**\n\n```{r, results = \"hold\"}\nn2\nn2 > 5\nn2[n2 > 5]\n```\n\n```{r, results = \"hold\"}\nbin\nn2[bin]\nn2[as.logical(bin)]\n```\n\n#### Exercise 1\n\nCreate a vector myvec which contains all numbers from 1 to 20 except 3 and 6. Subset fifth and fourth number by position.\n\n#### Exercise 2\n\nSubset myvec to get only numbers smaller or equal to 2 or larger than 17. Return first the numbers, then their positions in the original vector.\n\nSubset myvec to return only elements which are in positions divisible by 3.\n\n#### Exercise 3\n\nReturn words from vector ch which have more than 5 letters.\n\n## Data structures\n\n```         \n- vectors  \n- factors = vectors with (unchangeable) levels  \n- matrices = dataframes with 1 type of data  \n- lists  \n- data frames = pretty lists  \n```\n\n## Factors\n\nVectors with predefined levels.\\\nUsual suspects for your errors.\n\n```{r}\nfac <- factor(n3); fac\n```\n\n```{r, results = \"hold\"}\nfac[1] <- 6\nfac\n```\n\nSo how to turn a factor into normal numeric vector? There's a hack.\n\n```{r, results = \"hold\"}\nas.numeric(fac)\nas.numeric(as.character(fac))\n```\n\n## Matrices\n\n```{r}\nm <- matrix(1:15, nrow=5, ncol=3); m\n```\n\nSubsetting:\n\n```{r, results = \"hold\"}\nm[1,3]\nm[12]\nm[,2]\n```\n\nBasic functions:\n\n```{r, results = \"hold\"}\nt(m)      # transpose\ndiag(m)   # extract diagonal\ndim(m)    # see dimensions\n```\n\n#### Exercise 4\n\nMake a 4x4 matrix m2 with numbers from 1 to 16. Let the first row be: 1 2 3 4 (hint: consult help with ?matrix).\n\nChange all the numbers on the diagonal to zeroes.\n\nSum the elements in each row.\n\n## Lists\n\nStore anything; most flexible data type.\n\n```{r}\nl <- list(n2, bool, m, fac); l\n```\n\n## Lists\n\nLet's name the entries:\n\n```{r}\nnames(l) <- c(\"vector1\", \"vector2\", \"matrix1\", \"factor1\")\n```\n\nHow many entries?\n\n```{r}\nlength(l)\n```\n\nHow about dimensions?\n\n```{r}\ndim(l)\n```\n\n### List subsetting\n\nBy position:\n\n```{r, results = \"hold\"}\nl[2]\nclass(l[2])\n```\n\nBy position, another way:\n\n```{r, results = \"hold\"}\nl[[4]]\nclass(l[[4]])\n```\n\nBy name:\n\n```{r, results = \"hold\"}\nl$vector2\nclass(l$vector2)\nl[[\"factor1\"]]\n```\n\nSubset an element of an element:\n\n```{r}\nunlist(l[2])\nclass(unlist(l[2]))\n\nl[3]\nl[[3]][2,3]\n#l[3][2,3]\n\n```\n\n## Data frames\n\n\"Matrices\" with different types of data.\n\n```{r}\ndf <- data.frame(m, ch); df\ndim(df)\nncol(df); nrow(df)\ncolnames(df); rownames(df)\n```\n\n### Data frame subsetting\n\nBy position:\n\n```{r, results = \"hold\"}\ndf[2, 3]\ndf[, 3:4]\n```\n\nBy names:\n\n```{r, results = \"hold\"}\ndf[\"ch\"]\ndf$ch\nclass(df[\"ch\"])\nclass(df$ch)\n```\n\nInternally, data frames are lists with entries of equal lengths.\n\n## Data frames\n\nAdding a column:\n\n```{r}\ndf <- cbind(df, bool); df\n```\n\nRemoving a column:\n\n```{r}\ndf[\"bool\"] <- NULL; df\n```\n\nRemoving a row:\n\n```{r}\n#df[5, ] <- NULL; df\n\ndf <- df[-5, ]\n```\n\n#### Exercise 5\n\nR has a number of pre-loaded datasets, `iris` probably being the most famous one.\n\nLoad iris and calculate mean length of sepal.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"collapse":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"self-contained":true,"toc-depth":5,"output-file":"week1_lecture1.html"},"language":{"code-summary":"Show code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","editor":"visual","theme":"../styles.scss","mainfont":"Nunito","page-layout":"full","title":"Week 1 - Lecture 1"},"extensions":{"book":{"multiFile":true}}}}}