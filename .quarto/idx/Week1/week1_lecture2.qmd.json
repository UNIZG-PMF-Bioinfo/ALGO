{"title":"Week 1 - Lecture 2","markdown":{"yaml":{"title":"Week 1 - Lecture 2","format":{"html":{"self-contained":true,"toc":true,"toc-depth":5,"code-fold":false,"fig-align":"center","df-print":"paged","code-summary":"Show code","code-line-numbers":false,"code-tools":true}}},"headingText":"Functions","containsRefs":false,"markdown":"\n\n\n### General structure:\n\nmyfun **\\<- function(**input, parameters**) {**\\\ndo a thing\\\ndo another thing\\\n...\\\noutput\\\n**}**\n\n**Write a function**\n\nMake a simple function which will multiplies two numbers.\n\n```{r}\nmySimpleFun <- function(a=1,b) {\n    product <- a*b\n    return(product)\n}\n```\n\nThe function will return whatever is called on the last line, or you can explicitly state it with **return()**.\n\n**Execution i.e. calling a function**\n\n```{r}\nmySimpleFun(b=3)\nmySimpleFun(a=2, b=3)\nmySimpleFun(2, 3)\n```\n\n## Global and local variables\n\n```{r, eval=FALSE}\nmySimpleFun <- function(a=1,b) {\n    product <- a*b\n    return(product)\n}\n```\n\nWhat happens with the function if we change variable vol outside it? Nothing! The function has its own **local environment**.\n\n```{r}\nproduct <- 5\nmySimpleFun(2, 3)\nproduct\n```\n\n## Function as binary operator\n\nAll functions are beautiful, but not all come in the same shape :)\n\nAn **operator** is a function that takes one or two arguments and can be written without parentheses\n\n**function(**arg1, arg2**)**\\\nvs.\\\narg1 **operator** arg2\n\nOperator **%in%** is used to identify if an element belongs to a vector or dataframe.\n\n```{r}\nc(1,4,2,1) %in% c(2,3)\n```\n\n## Multiple inputs / vectorisation\n\n```{r}\nmySimpleFun(1:3, 3:5)\n```\n\n## Flow control: if statement\n\n**if(**condition is fulfilled**) {**\\\ndo the thing\\\n**} else {**\\\ndo the other thing\\\n**}**\n\n```{r}\nmySimpleFun <- function(a=1,b) {\n    if (a < 0) {\n        a <- (-1)*a\n    } else {\n        a <- a\n    }\n    \n    product <- a*b\n    return(product)\n}\n```\n\n## Warnings, errors and messages\n\nYou are getting the hang of this, and with an additional pair of hands the work is coming along quickly. But after one calculation, you notice the numbers are fishy. Upon closer inspection, you discover that you input thickness with a decimal dot in the wrong place. To prevent this from happening again and going unnoticed, you add a **warning()**:\n\n```{r}\nmySimpleFun <- function(a=1,b) {\n    if (a < 0) {\n        warning(\"First number is negative! Changing it to positive.\")\n        a <- (-1)*a\n    } else {\n        a <- a\n    }\n    \n    product <- a*b\n    return(product)\n}\n```\n\nIf you want the function to stop executing, use **break()**.\\\n**message()** has similar syntax but different \"level of alert\".\n\n## Multiple outputs\n\n```{r}\nmySimpleFun <- function(a=1,b) {\n    if (a < 0) {\n        warning(\"First number is negative! Changing it to positive.\")\n        a <- (-1)*a\n    } else {\n        a <- a\n    }\n    # calculate product\n    product <- a*b\n    # make a figure\n    figure <-  plot(c(a,b))\n    # save a list\n    res_list <- list(\"product\"=product, \"figure\"=figure)\n    # return\n    return(res_list)\n}\n## run the fuction\nmySimpleFun(b=-2)\n```\n\n**`ifelse(test, yes, no)`** - vectorised\n\n```{r}\nmySimpleFun <- function(a=1,b) {\n  # make all negatives positive\n  a <- ifelse(a < 0, -a, a)\n\n  # calculate product\n  product <- a * b\n\n  # (plots will only show the last one in a loop, so you usually donâ€™t do this inside)\n  plot(a, b)   # e.g. scatter plot\n\n  list(product = product)\n}\n\nmySimpleFun(a= c(2,3,2,-1), b=c(3,4,5,2))\n```\n\nTry to change 'list' with 'c' and see what happens. You have to put multiple outputs together as a list, otherwise it doesn't work properly!\n\n## Looping in R\n\n**for(**each value in sequence**) {**\\\ndo the thing\\\n**}**\n\n```{r}\nfor(i in 1:5) {\n    print(\"bla\")\n}\n```\n\n**while(**condition is true**) {**\\\ndo the thing\\\n**}**\n\n**repeat {**\\\nthe thing\\\n**if(**condition is true**) { break }**\\\n**}**\n\nIt's **NEVER** a time for a loop in R. Instead, there's the **apply()** family of functions:\n\n## Apply family of functions\n\n**lapply()**:\n\n```{r}\nlapply(iris[, 1:4], sum)          # preforms a function over each list element\nclass(lapply(iris[, 1:4], sum))   # returns a list\n```\n\nNotice the three dots (ellipsis) in function description: `lapply(X, FUN, ...)`\n\nAccess list entries explicitly by using **function(x)**:\n\n```{r}\nlapply(iris[, 1:4], function(x) sqrt(x[20:30]))\n```\n\n## Apply family of functions\n\n**`sapply()`** : lapply, but tries to return simpler data format\n\n```{r}\nsapply(iris[, 1:4], sum)\nclass(sapply(iris[, 1:4], sum))\n```\n\n## Apply family of functions\n\n**`apply()`** : apply function over margins of array (1 for rows, 2 for columns)\n\n```{r}\napply(iris[, 1:4], 1, sum)\n```\n\n## Apply family of functions\n\n**`replicate()`** : repeated evaluation of expression; returns an array\n\n```{r}\nreplicate(3, sample(1:10, 5))\n```\n\n## Take home messages on writing your own functions\n\nTake care of the future user of your function - it'll probably be you.\n\n-   tidy and clear commands - avoid salami code\n-   tidy and logical higher structures - avoid spaghetti code\n-   sensible function and variable names\n-   (b, bb, bbs, dajproradivise, omg, matfixmerggr)\n-   COMMENT YOUR CODE\n\n```{r}\n# example of salami code:\nsum(as.numeric(names(table(sample(50:300, 1000, replace=T) %/% 25))))   \n```\n\nvs.\n\n```{r}\nmysample <- sample(50:300, 1000, replace=T)\nroundit <- mysample %/% 25\ntb <- table(roundit)\ntb\ncategories <- as.numeric(names(tb))\ncategories\ncat_sum <- sum(categories)\ncat_sum\n```\n\nMost importantly, if there is already a function for what you are trying to do, don't write your own without a good reason. (Homework instructions are a good reason.)\n\n# The end\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"collapse":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"center","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"self-contained":true,"toc-depth":5,"output-file":"week1_lecture2.html"},"language":{"code-summary":"Show code"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","editor":"visual","theme":"../styles.scss","mainfont":"Nunito","page-layout":"full","title":"Week 1 - Lecture 2"},"extensions":{"book":{"multiFile":true}}}}}